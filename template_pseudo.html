# @title html template
%%writefile template.html
<!-- CHANGELOG: Added QC UMAP scale, expanded signature panel, and removed contour overlay -->
<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Interactive Gene‑Expression Dashboard</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js" integrity="sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs" crossorigin="anonymous"></script>
<script defer src="https://cdn.plot.ly/plotly-2.32.0.min.js" integrity="sha384-7TVmlZWH60iKX5Uk7lSvQhjtcgw2tkFjuwLcXoRSR4zXTyWFJRm9aPAguMh7CIra" crossorigin="anonymous"></script>
<link href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.min.css" rel="stylesheet" integrity="sha384-AGH1YNmRghVFwHPLe/1yQlJZ3+2p9+wRBmvXrf5RuGjxKk8UjfVADoMXNfTvSx/1" crossorigin="anonymous">
<script defer src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js" integrity="sha384-O1JpKVMD58eq3U48XcwVq+pS1c0Q7gdbGHi3oBETeJYQhh6/9XJ9vjHWgtV+xn4o" crossorigin="anonymous"></script>
<link href="https://cdn.datatables.net/buttons/2.4.1/css/buttons.dataTables.min.css" rel="stylesheet">
<script defer src="https://cdn.datatables.net/buttons/2.4.1/js/dataTables.buttons.min.js"></script>
<script defer src="https://cdn.datatables.net/buttons/2.4.1/js/buttons.html5.min.js"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js" integrity="sha384-rNlaE5fs9dGIjmxWDALQh/RBAaGRYT5ChrzHo6tRfgrZ36iRFAiquP5g41Jsv+0j" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; margin:20px; }
  .nav-tabs .nav-link.active { border-bottom:3px solid #0d6efd; font-weight:600; }
  .tabpane { display:none; }
  .tabpane.show { display:block; }
  .qcsubpane { display:none; }
  .qcsubpane.show { display:block; }
</style>
<style>
  /* ===== Design tokens ===== */
  :root{
    --font-sans: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    --bg: #fafafa; --surface:#ffffff; --border:#e6e8eb; --muted:#6b7280; --text:#0b1220;
    --brand:#0d6efd; --brand-600:#0b5ed7; --success:#16a34a; --warn:#f59e0b; --danger:#dc2626;
    --radius:16px; --shadow:0 1px 2px rgba(16,24,40,.04),0 10px 20px rgba(16,24,40,.06);
    --space-1:.25rem; --space-2:.5rem; --space-3:.75rem; --space-4:1rem; --space-6:1.5rem;
  }
  body{ font-family:var(--font-sans); background:var(--bg); color:var(--text); }
  .logoSVG{ opacity:.9; filter:grayscale(.1) saturate(.9); }
  /* Container rhythm */
  body > .d-flex{ margin-bottom:var(--space-4); }
  .tabpane{ display:none; } .tabpane.show{ display:block; }
  .tabpane .row{ row-gap: var(--space-4); }
  .plot-area{ width:100%; height:clamp(300px, calc(100vh - 200px), 800px); }
  /* Nav styling */
  .nav-tabs{ border-bottom:1px solid var(--border); }
  .nav-tabs .nav-link{ border:0; color:var(--muted); font-weight:600; padding:.6rem 1rem; }
  .nav-tabs .nav-link.active{ color:var(--text); border-bottom:3px solid var(--brand); }
  /* Sticky per-tab toolbar (first .d-flex inside a tab) */
  .tabpane .d-flex.align-items-center{ position:sticky; top:0; z-index:5;
    background:var(--bg); padding:var(--space-3) var(--space-4); margin:-.5rem -.5rem var(--space-3);
    border-radius:calc(var(--radius) - 8px); border:1px solid var(--border); box-shadow:var(--shadow);
  }
  /* Card-like plot and table frames (no markup changes needed) */
  [id$="Plot_§DOM"], [id^="clusterPlot_"], [id^="genePlot_"], [id^="markerUMAP_"],
  [id^="topMarkerUMAP_"], [id^="enrichUMAP_"], [id^="enrichViolin_"], #tfBarplot,
    [id^="coexprPlot_§DOM"], #compBar, #dirichletForest{
      background:var(--surface); border:1px solid var(--border); border-radius:var(--radius);
      box-shadow:var(--shadow); padding: var(--space-2);
    }
    .umapObsGrid{ display:grid; gap:var(--space-4); }
  .umapObsGrid > div{
      background:var(--surface); border:1px solid var(--border); border-radius:var(--radius);
      box-shadow:var(--shadow); padding:var(--space-2); aspect-ratio:1; display:flex;
      align-items:center; justify-content:center;
    }
  [id^="umapObsPlot_"]{ background-color:#6c757d; border-color:#6c757d; }
  [id^="umapObsPlot_"]:hover,[id^="umapObsPlot_"]:focus,[id^="umapObsPlot_"]:active{ background-color:#6c757d; border-color:#6c757d; }
  /* Tables */
  table.table{ background:var(--surface); border:1px solid var(--border); border-radius:var(--radius);
    overflow:hidden; box-shadow:var(--shadow); }
  table.table thead th{ background:#f8fafc; font-weight:700; }
  table.table tbody tr:hover{ background:#f3f4f6; }
  table.table td, table.table th{ vertical-align:middle; white-space:nowrap; }
  /* Small controls, tidy spacing */
  .form-label{ color:var(--muted); font-size:.85rem; }
  .form-select.form-select-sm, .form-control.form-control-sm{ border-radius:10px; }
  .btn.btn-sm{ border-radius:10px; }
  /* AI Insights typography */
  #biologyContent{ max-width: 90ch; background:var(--surface); border:1px solid var(--border);
    border-radius:var(--radius); box-shadow:var(--shadow); }
  #biologyContent h1,#biologyContent h2,#biologyContent h3{ margin-top:1.4em; }
  #biologyContent code, #biologyContent pre{ background:#f3f4f6; color:var(--text); border-radius:10px; padding:.4rem .6rem; }
  .card{ border-radius:var(--radius); border:1px solid var(--border); box-shadow:var(--shadow); }

  /* ===== About tab polish (NEW) ===== */
  .about-hero { background: var(--surface); border:1px solid var(--border); border-radius:var(--radius); }
  .about-hero .lead { font-weight: 500; }
  .about-mission { padding-left: 1.1rem; }
  .about-mission li + li { margin-top: .25rem; }

  .about-grid .card { border:1px solid var(--border); border-radius:var(--radius); box-shadow:var(--shadow); }

  /* Legal block styling */
  .legal-pre{
    white-space:pre-wrap;
    background:#f8fafc;
    border:1px solid var(--border);
    border-radius:10px;
    padding:.6rem;
  }

  /* Compact, readable key–value list */
  .about-kv { display:grid; grid-template-columns: 140px 1fr; row-gap:.35rem; column-gap:1rem; margin:0; }
  .about-kv dt { color:var(--muted); font-weight:600; }
  .about-kv dd { margin:0; }

  /* Footer tagline */
  .about-tagline { position:relative; padding-right:.25rem; }
  .about-tagline .about-dot { display:inline-block; width:.4rem; height:.4rem; border-radius:50%; background:#0d6efd; margin:0 .15rem; opacity:.4; }
  .about-tagline .about-text { margin-left:.4rem; font-weight:700; color:var(--brand); letter-spacing:.3px; }
  #globalFooter{position:fixed; bottom:.5rem; right:.5rem;}
  /* Accessible focus */
  :focus-visible{ outline:3px solid color-mix(in oklab, var(--brand) 40%, white); outline-offset:2px; border-radius:12px; }
  /* Help slide-over */
  #helpOverlay{position:fixed;top:0;right:0;bottom:0;width:360px;max-width:90%;background:var(--surface);
    border-left:1px solid var(--border);box-shadow:var(--shadow);transform:translateX(100%);transition:transform .3s;z-index:1050;
    overflow-y:auto;padding:var(--space-4);}
  #helpOverlay.show{transform:translateX(0);}
  #helpBackdrop{position:fixed;inset:0;background:rgba(0,0,0,.3);z-index:1040;opacity:0;transition:opacity .3s;display:none;}
  #helpBackdrop.show{display:block;opacity:1;}
  #tourOverlay{position:fixed;inset:0;background:rgba(0,0,0,.6);color:#fff;display:none;z-index:1100;
    align-items:center;justify-content:center;text-align:center;padding:1rem;}
  #tourOverlay.show{display:flex;}
</style>
<script>
  const PLOTLY_THEME = {
    layout: {
      font:{family:'', size:13},
      paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)',
      margin:{l:10,r:10,t:28,b:10},
      xaxis:{visible:false,zeroline:false,showgrid:false},
      yaxis:{visible:false,zeroline:false,showgrid:false,scaleanchor:'x',scaleratio:1},
      hoverlabel:{align:'left',namelength:-1, bgcolor:'rgba(255,255,255,.9)', font:{color:'#0b1220'}}
    },
    config:{displaylogo:false, responsive:true, modeBarButtonsToRemove:['lasso2d','select2d','toggleSpikelines']}
  };
  document.addEventListener('DOMContentLoaded', () => {
    PLOTLY_THEME.layout.font.family = getComputedStyle(document.body).fontFamily;
  });
  // Use like: Plotly.react(container, traces, {...PLOTLY_THEME.layout, title:'My title'}, PLOTLY_THEME.config)
</script>
<script>
  function onVisible(el, cb) {
    const run = () => {
      if (el.offsetParent !== null) {
        cb();
        return true;
      }
      return false;
    };
    if (run()) return;
    if ('IntersectionObserver' in window) {
      const io = new IntersectionObserver((entries, obs) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            obs.disconnect();
            cb();
          }
        });
      });
      io.observe(el);
    } else if ('MutationObserver' in window) {
      const mo = new MutationObserver(() => {
        if (run()) mo.disconnect();
      });
      mo.observe(document.documentElement, { attributes:true, childList:true, subtree:true });
    } else {
      const interval = setInterval(() => {
        if (run()) clearInterval(interval);
      }, 200);
    }
  }
</script>
</head>
<body>
<svg style="position:absolute;width:0;height:0;overflow:hidden" aria-hidden="true">
  <defs>
    <g id="logoSymbol">
      <!-- Colors: Dark blue outline/stroke (#000080), yellow fill (#FFD700), light blue fill (#00BFFF), brown fill (#8B4513), purple fill (#800080) -->
      <!-- Yellow circle (left) -->
      <circle cx="60" cy="90" r="35" fill="#FFD700" stroke="#000080" stroke-width="8" />
      <!-- Horizontal main line -->
      <line x1="95" y1="90" x2="340" y2="90" stroke="#000080" stroke-width="8" stroke-linecap="round" />
      <!-- Upward curved branch to light blue circle -->
      <path d="M130 90 C150 50, 170 50, 190 70" fill="none" stroke="#000080" stroke-width="8" stroke-linecap="round" />
      <circle cx="190" cy="70" r="20" fill="#00BFFF" stroke="#000080" stroke-width="8" />
      <!-- Downward curved branch to brown square -->
      <path d="M220 90 C240 130, 260 130, 280 110" fill="none" stroke="#000080" stroke-width="8" stroke-linecap="round" />
      <rect x="270" y="95" width="25" height="25" rx="5" fill="#8B4513" stroke="#000080" stroke-width="8" />
      <!-- Purple triangle (right arrow‑like) -->
      <polygon points="340,70 370,90 340,110" fill="#800080" stroke="#000080" stroke-width="8" stroke-linejoin="round" />
      <!-- Text "STREAM" below -->
      <text x="70" y="200" fill="#000080" font-family="sans-serif" font-weight="bold" font-size="70">STREAM</text>
    </g>
  </defs>
</svg>
<!-- compact logo + title bar -->
<div class="d-flex align-items-center mb-3">
<svg class="logoSVG" style="max-width:220px;" viewBox="0 0 400 250" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="STREAM logo"><use href="#logoSymbol"/></svg>
  <h2 class="mb-0">Streamlined Toolkit for Real-time Exploratory Analysis of Multiomics</h2>
</div>
<ul class="nav nav-tabs mb-3">
  <li class="nav-item">
    <a class="nav-link active" data-tab="umap" href="#">Clusters &amp; Genes</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="umapobs" href="#">Sample/Condition</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="markers" href="#">Marker genes</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="topmarkers" href="#">Neighborhood-aware markers</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="enrich" href="#">Predicted annotation</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="tf" href="#">TF enrichment</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="coexpr" href="#">Co-expression</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="composition" href="#">Composition</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="volcano" href="#">Volcano</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="dge" href="#">DGE</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="biology" href="#">AI Insights</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="qc" href="#">QC</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="methods" href="#">Methods</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="about" href="#">About</a>
  </li>
  <li class="nav-item ms-auto d-flex align-items-center">
    <button id="helpChip" class="btn btn-sm btn-outline-secondary">Help</button>
  </li>
</ul>
  <div id="umap" class="tabpane show">
    <div class="d-flex gap-2 align-items-center mb-2">
      <label class="form-label mb-0" for="geneInput_§DOM">RNA</label>
      <input list="geneList_§DOM" id="geneInput_§DOM" class="form-control form-control-sm" style="max-width:260px" aria-describedby="geneFeedback_§DOM" placeholder="e.g., LST1" />
      <datalist id="geneList_§DOM"></datalist>
      <label class="form-label mb-0 protCtrl" for="proteinInput_§DOM">Protein</label>
      <input list="protList_§DOM" id="proteinInput_§DOM" class="form-control form-control-sm protCtrl" style="max-width:260px" placeholder="e.g., CD3">
      <datalist id="protList_§DOM"></datalist>
      <label class="form-label mb-0 protCtrl" for="viewToggle_§DOM">View:</label>
      <div class="btn-group btn-group-sm protCtrl" role="group" id="viewToggle_§DOM">
        <input type="radio" class="btn-check" name="umapView_§DOM" id="viewRNA_§DOM" value="RNA" autocomplete="off">
        <label class="btn btn-outline-secondary" for="viewRNA_§DOM">RNA</label>
        <input type="radio" class="btn-check" name="umapView_§DOM" id="viewPROT_§DOM" value="PROT" autocomplete="off">
        <label class="btn btn-outline-secondary" for="viewPROT_§DOM">Protein</label>
        <input type="radio" class="btn-check" name="umapView_§DOM" id="viewBOTH_§DOM" value="BOTH" autocomplete="off">
        <label class="btn btn-outline-secondary" for="viewBOTH_§DOM">Both</label>
      </div>
      <div class="form-check form-switch mb-0 protCtrl">
        <input class="form-check-input" type="checkbox" id="linkRanges_§DOM" checked>
        <label class="form-check-label" for="linkRanges_§DOM">Link ranges</label>
      </div>
      <button id="plotCluster_§DOM" class="btn btn-sm btn-secondary">Plot clusters</button>
    </div>
    <div id="geneFeedback_§DOM" class="visually-hidden" aria-live="polite"></div>
    <div class="row">
      <div class="col-md-6 col-lg-4" id="clustCol_§DOM">
        <div id="clusterPlot_§DOM" class="plot-area"></div>
      </div>
      <div class="col-md-6 col-lg-4" id="rnaCol_§DOM">
        <div id="genePlot_§DOM" class="plot-area"></div>
      </div>
      <div class="col-md-6 col-lg-4 d-none" id="protCol_§DOM">
        <div id="protPlot_§DOM" class="plot-area"></div>
      </div>
    </div>
  </div>
  <div id="umapobs" class="tabpane">
    <div class="d-flex gap-2 align-items-center mb-2">
      <label class="form-label mb-0 protCtrl" for="umapObsMod_§DOM">Modality</label>
      <select id="umapObsMod_§DOM" class="form-select form-select-sm protCtrl" style="max-width:130px">
        <option value="RNA">RNA</option>
        <option value="Protein">Protein</option>
      </select>
      <label class="form-label mb-0" for="umapObsFeat_§DOM">Feature</label>
      <input id="umapObsFeat_§DOM" class="form-control form-control-sm" style="max-width:260px" list="geneList_§DOM" placeholder="e.g., LST1" />
      <label class="form-label mb-0" for="obsGroupSel_§DOM">Group by</label>
      <select id="obsGroupSel_§DOM" class="form-select form-select-sm" style="max-width:200px"></select>
      <label class="form-label mb-0" for="umapObsView_§DOM">View</label>
      <div class="btn-group btn-group-sm" role="group" id="umapObsView_§DOM">
        <input type="radio" class="btn-check" name="umapObsView_§DOM" id="umapObsViewUMAP_§DOM" value="umap" autocomplete="off" checked>
        <label class="btn btn-outline-secondary" for="umapObsViewUMAP_§DOM">UMAP</label>
        <input type="radio" class="btn-check" name="umapObsView_§DOM" id="umapObsViewViolin_§DOM" value="violin" autocomplete="off">
        <label class="btn btn-outline-secondary" for="umapObsViewViolin_§DOM">Violin</label>
      </div>
      <label class="form-label mb-0" for="umapObsPoints_§DOM">Points</label>
      <select id="umapObsPoints_§DOM" class="form-select form-select-sm" style="max-width:150px">
        <option value="all" selected>All</option>
        <option value="none">None</option>
        <option value="suspectedoutliers">Outliers</option>
      </select>
      <div class="form-check form-switch mb-0">
        <input class="form-check-input" type="checkbox" id="umapObsJitter_§DOM" value="0.3">
        <label class="form-check-label" for="umapObsJitter_§DOM">Jitter</label>
      </div>
      <div class="form-check form-switch mb-0">
        <input class="form-check-input" type="checkbox" id="obsShowBackground_§DOM" checked>
        <label class="form-check-label" for="obsShowBackground_§DOM">Show background</label>
      </div>
      <button id="umapObsPlot_§DOM" class="btn btn-sm btn-secondary">Plot clusters</button>
    </div>
    <h5 id="umapObsTitle_§DOM" class="text-center mb-3"></h5>
    <div id="umapObsGrid_§DOM" class="umapObsGrid"></div>
    <div id="umapObsViolin_§DOM" class="plot-area" style="display:none;"></div>
  </div>
  <div id="markers" class="tabpane">
    <div class="d-flex gap-2 align-items-center mb-2">
      <label class="form-label mb-0" for="methodSel_§DOM" id="methodLbl_§DOM">Method</label>
      <select id="methodSel_§DOM" class="form-select form-select-sm" style="max-width:130px"></select>
      <label class="form-label mb-0" for="clusterSel_§DOM">Cluster</label>
      <select id="clusterSel_§DOM" class="form-select form-select-sm" style="max-width:130px"></select>
    </div>
    <div class="row">
      <div class="col-md-6">
        <table id="markerTable_§DOM" class="table table-sm table-hover"></table>
      </div>
      <div class="col-md-6">
        <div id="markerUMAP_§DOM" class="plot-area"></div>
      </div>
    </div>
  </div>
  <div id="topmarkers" class="tabpane">
    <div class="d-flex gap-2 align-items-center mb-2">
      <label class="form-label mb-0 d-none" for="topModalitySel_§DOM" id="topModalityLbl_§DOM">Modality</label>
      <select id="topModalitySel_§DOM" class="form-select form-select-sm d-none" style="max-width:130px"></select>
      <label class="form-label mb-0" for="topClusterSel_§DOM">Cluster</label>
      <select id="topClusterSel_§DOM" class="form-select form-select-sm" style="max-width:130px"></select>
    </div>
    <div class="row">
      <div class="col-md-6">
        <table id="topMarkerTable_§DOM" class="table table-sm table-hover"></table>
      </div>
      <div class="col-md-6">
        <div id="topMarkerUMAP_§DOM" class="plot-area"></div>
      </div>
    </div>
  </div>
  <div id="enrich" class="tabpane">
    <div class="d-flex gap-2 align-items-center mb-2">
      <label class="form-label mb-0" for="enrichClusterSel_§DOM">Cluster</label>
      <select id="enrichClusterSel_§DOM" class="form-select form-select-sm" style="max-width:130px"></select>
      <label class="form-label mb-0" for="enrichTypeSel_§DOM">Predicted</label>
      <select id="enrichTypeSel_§DOM" class="form-select form-select-sm" style="max-width:180px"></select>
      <button id="enrichDownload_§DOM" class="btn btn-sm btn-outline-secondary ms-auto">Download CSV</button>
    </div>
    <div class="row">
      <div class="col-md-6">
        <div id="enrichUMAP_§DOM" class="plot-area"></div>
      </div>
      <div class="col-md-6">
        <div id="enrichViolin_§DOM" class="plot-area"></div>
      </div>
    </div>
  </div>
  <div id="tf" class="tabpane">
    <div class="d-flex gap-2 align-items-center mb-2">
      <label class="form-label mb-0" for="tfCelltype">Cell type</label>
      <select id="tfCelltype" class="form-select form-select-sm" style="max-width:130px"></select>
    </div>
    <div class="row">
      <div class="col-md-6">
        <div id="tfBarplot" class="plot-area"></div>
      </div>
      <div class="col-md-6"></div>
    </div>
  </div>
  <div id="coexpr" class="tabpane">
  <div class="row g-3">
    <div class="col-md-8">
      <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
        <label class="form-label mb-0" for="geneAInput_§DOM">Gene&nbsp;A</label>
        <input list="geneList_§DOM" id="geneAInput_§DOM" class="form-control form-control-sm" style="max-width:150px">
        <label class="form-label mb-0" for="geneBInput_§DOM">Gene&nbsp;B</label>
        <input list="geneList_§DOM" id="geneBInput_§DOM" class="form-control form-control-sm" style="max-width:150px">
        <label class="form-label mb-0" for="modeSel_§DOM">Mode</label>
        <select id="modeSel_§DOM" class="form-select form-select-sm" style="max-width:120px">
          <option value="bivariate">bivariate</option>
          <option value="ratio">ratio</option>
        </select>
        <label class="form-label mb-0" for="transformSel_§DOM">Transform</label>
        <select id="transformSel_§DOM" class="form-select form-select-sm" style="max-width:120px">
          <option value="raw">raw</option>
          <option value="log1p">log1p</option>
          <option value="logratio">logratio</option>
        </select>
        <!-- NEW: separate quantile sliders for gene A and B with suggestion captions -->
        <label class="form-label mb-0" for="quantileA_§DOM">A&nbsp;quant</label>
        <div class="d-flex flex-column align-items-stretch" style="width:110px">
          <input type="range" id="quantileA_§DOM" class="form-range" min="0.1" max="0.9" step="0.01" value="0.5" list="quantTicks_§DOM">
          <datalist id="quantTicks_§DOM">
            <option value="0.1"></option>
            <option value="0.5"></option>
            <option value="0.9"></option>
          </datalist>
          <div class="d-flex justify-content-between small text-muted"><span>0.1</span><span>0.5</span><span>0.9</span></div>
          <div id="suggestCaptionA_§DOM" class="small text-muted"></div>
        </div>
        <button id="suggestA_§DOM" class="btn btn-sm btn-outline-secondary" aria-label="Suggest A threshold">Suggest</button>
        <label class="form-label mb-0" for="quantileB_§DOM">B&nbsp;quant</label>
        <div class="d-flex flex-column align-items-stretch" style="width:110px">
          <input type="range" id="quantileB_§DOM" class="form-range" min="0.1" max="0.9" step="0.01" value="0.5" list="quantTicks_§DOM">
          <div class="d-flex justify-content-between small text-muted"><span>0.1</span><span>0.5</span><span>0.9</span></div>
          <div id="suggestCaptionB_§DOM" class="small text-muted"></div>
        </div>
        <button id="suggestB_§DOM" class="btn btn-sm btn-outline-secondary" aria-label="Suggest B threshold">Suggest</button>
        <label class="form-label mb-0" for="clip_§DOM">Clip&nbsp;%</label>
        <div class="d-flex flex-column align-items-stretch" style="width:120px">
          <input type="range" id="clip_§DOM" class="form-range" style="width:100%" min="50" max="98" step="1" value="98" list="clipTicks_§DOM">
          <datalist id="clipTicks_§DOM">
            <option value="50"></option>
            <option value="74"></option>
            <option value="98"></option>
          </datalist>
          <div class="d-flex justify-content-between small text-muted">
            <span>50</span><span>74</span><span>98</span>
          </div>
        </div>
        <div class="form-check form-switch mb-0">
          <input class="form-check-input" type="checkbox" id="binarize_§DOM">
          <label class="form-check-label" for="binarize_§DOM">Binarize</label>
        </div>
        <label class="form-label mb-0" for="binarizeQ_§DOM">Thresh</label>
        <div class="d-flex flex-column align-items-stretch" style="width:120px">
          <input type="range" id="binarizeQ_§DOM" class="form-range" style="width:100%" min="0.1" max="0.9" step="0.01" value="0.5" list="binTicks_§DOM">
          <datalist id="binTicks_§DOM">
            <option value="0.1"></option>
            <option value="0.5"></option>
            <option value="0.9"></option>
          </datalist>
          <div class="d-flex justify-content-between small text-muted">
            <span>0.1</span><span>0.5</span><span>0.9</span>
          </div>
        </div>
        <div class="form-check form-switch mb-0">
          <input class="form-check-input" type="checkbox" id="globalScale_§DOM">
          <label class="form-check-label" for="globalScale_§DOM">Global scale</label>
        </div>
      </div>
      <!-- Container for co-expression plot -->
      <div id="coexprPlotWrap_§DOM" style="position:relative;width:100%;height:clamp(300px, calc(100vh - 240px), 800px)">
        <div id="coexprPlot_§DOM" style="width:100%;height:100%"></div>
      </div>
      <div id="coexprLegend_§DOM" class="mt-2"></div>
    </div>
    <div class="col-md-4">
      <table id="ratioTable_§DOM" class="table table-sm table-hover"></table>
      <!-- Signature scoring panel -->
      <details id="sigPanel_§DOM" class="mt-3" open>
        <summary class="fw-bold">Signature</summary>
        <div class="mt-2">
          <textarea id="sigGenes_§DOM" class="form-control form-control-sm mb-2" rows="10">MCM5
PCNA
E2F1</textarea>
          <select id="sigMethod_§DOM" class="form-select form-select-sm mb-2" aria-label="Signature method">
            <option value="meanZ" selected>Mean z-score</option>
          </select>
          <button id="sigScoreBtn_§DOM" class="btn btn-sm btn-primary mb-2">Score</button>
          <div id="sigInfo_§DOM" class="small text-muted mb-2"></div>
          <div id="sigUMAP_§DOM" style="width:100%;height:250px"></div>
        </div>
      </details>
  </div>
  </div>
  </div>
  <div id="composition" class="tabpane">
    <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
      <label class="form-label mb-0" for="compSampleKey">Sample key</label>
      <select id="compSampleKey" class="form-select form-select-sm" style="max-width:160px" aria-label="Sample key"></select>
      <label class="form-label mb-0" for="compGroupBy">Group by</label>
      <select id="compGroupBy" class="form-select form-select-sm" style="max-width:160px" aria-label="Group by"></select>
      <label class="form-label mb-0" for="compNorm">Normalize</label>
      <select id="compNorm" class="form-select form-select-sm" style="max-width:140px" aria-label="Normalize">
        <option value="props">Proportions</option>
        <option value="counts" selected>Counts</option>
      </select>
      <label class="form-label mb-0" for="compBarType">Bar mode</label>
      <select id="compBarType" class="form-select form-select-sm" style="max-width:140px" aria-label="Bar mode">
        <option value="stack">Stacked</option>
        <option value="group" selected>Grouped</option>
      </select>
      <button id="compDownloadCounts" class="btn btn-sm btn-outline-secondary" aria-label="Download counts CSV">Composition CSV (counts)</button>
      <button id="compDownloadProps" class="btn btn-sm btn-outline-secondary" aria-label="Download proportions CSV">Composition CSV (proportions)</button>
    </div>
    <div class="row g-3">
      <div class="col-12"><div id="compBar" style="width:100%;height:400px"></div></div>
      <div class="col-12"><table id="compTable" class="table table-sm table-striped"></table></div>
      <div class="col-12" id="dirichletPanel" style="display:none;">
        <div id="dirichletForest" style="width:100%;height:400px" class="mb-3"></div>
        <table id="dirichletTable" class="table table-sm table-hover"></table>
      </div>
    </div>
  </div>
  <div id="volcano" class="tabpane">
    <div class="d-flex gap-2 align-items-center mb-2">
      <label class="form-label mb-0" for="volcanoCelltype">Cell type</label>
      <select id="volcanoCelltype" class="form-select form-select-sm" style="max-width:160px"></select>
    </div>
    <div class="row g-3">
      <div class="col-md-6"><div id="volcanoPlot" class="plot-area"></div></div>
      <div class="col-md-6"><div id="volcanoBox" class="plot-area"></div></div>
    </div>
  </div>
  <div id="dge" class="tabpane">
    <div class="d-flex gap-2 align-items-center mb-2">
      <label class="form-label mb-0" for="dgeCelltype">Cell type</label>
      <select id="dgeCelltype" class="form-select form-select-sm" style="max-width:160px"></select>
    </div>
    <div class="row g-3">
      <div class="col-md-6">
        <table id="dgeTable" class="table table-sm table-hover"></table>
      </div>
      <div class="col-md-6">
        <div id="dgeBox" class="plot-area"></div>
      </div>
    </div>
  </div>
  <div id="biology" class="tabpane">
    <div class="row g-3">
      <div class="col-md-6"><div id="aiInsightsUMAP_§DOM" class="plot-area"></div></div>
      <div class="col-md-6">
        <div class="d-flex justify-content-end mb-2">
          <button id="downloadInsightsBtn" class="btn btn-sm btn-outline-secondary">Download table</button>
        </div>
        <div id="biologyContent" class="p-3">Loading...</div>
      </div>
    </div>
  </div>
  <div id="qc" class="tabpane">
    <ul class="nav nav-pills mb-3" id="qcSubTabs">
      <li class="nav-item"><a class="nav-link active" data-sub="Overview" href="#">Overview</a></li>
      <li class="nav-item"><a class="nav-link" data-sub="PerCluster" href="#">Per-cluster</a></li>
      <li class="nav-item"><a class="nav-link" data-sub="Batch" href="#">Batch / Integration</a></li>
    </ul>
    <div id="qc_Overview" class="qcsubpane show">
      <div class="row">
        <div class="col-lg-9">
          <div id="qc_metric_buttons" class="mb-2"></div>
          <div class="row g-3">
            <div class="col-md-6"><div id="qc_umap" style="width:100%;height:400px"></div></div>
            <div class="col-md-6"><div id="qc_hist" style="width:100%;height:400px"></div></div>
          </div>
          <div class="mt-3" id="qc_summary"></div>
        </div>
        <div class="col-lg-3" id="qc_gates"></div>
      </div>
    </div>
    <div id="qc_PerCluster" class="qcsubpane">
      <div class="d-flex align-items-center gap-2 mb-2">
        <label for="qc_cluster_sel" class="form-label mb-0">Cluster</label>
        <select id="qc_cluster_sel" class="form-select form-select-sm" style="max-width:160px"></select>
        <div class="form-check">
          <input class="form-check-input" type="checkbox" id="qc_show_all">
          <label class="form-check-label small" for="qc_show_all">Show all</label>
        </div>
      </div>
      <div id="qc_violin" class="mb-3"></div>
      <div id="qc_cluster_table"></div>
    </div>
    <div id="qc_Batch" class="qcsubpane">
      <div id="qc_batch_umap" style="width:100%;height:400px" class="mb-3"></div>
      <div class="row g-3">
        <div class="col-md-6"><div id="qc_mixing_umap" style="width:100%;height:300px"></div></div>
        <div class="col-md-6"><div id="qc_ilisi_umap" style="width:100%;height:300px"></div></div>
      </div>
      <div id="qc_batch_table" class="mt-3"></div>
    </div>
  </div>
  <div id="methods" class="tabpane">
    <div class="card p-4 mb-3">
      <h4 class="mb-3">Methods — STREAM v2.0 dashboard build</h4>

      <h5 class="mt-3">Marker genes</h5>
      <p class="mb-2">
        We compute per-cluster differential expression with Scanpy’s <code>tl.rank_genes_groups</code> using
        two statistics (<em>wilcoxon</em>, <em>t-test</em>). For each method we contrast the selected
        <code>leiden</code> cluster against the rest, keep genes with adjusted p &lt; 0.05 (Bonferroni), and display the
        top hits by the method’s score (up to 50 per cluster). For readability, known aliases are appended to symbols
        in the table (display only).
      </p>

      <h6 class="mt-2">Neighborhood-aware markers</h6>
      <p class="mb-2">
        To make marker calls more specific to local micro-populations, we compare each cluster against its
        <em>K</em> most-connected neighboring clusters on the KNN graph (default K = 3). We build a cluster-by-cluster
        connectivity matrix by summing cell-level graph weights (<code>obsp['connectivities']</code>), pick the top-K
        neighbors per cluster, and run <code>rank_genes_groups</code> (wilcoxon) with the target cluster as the
        <code>group</code> and the pooled neighbors as the <code>reference</code>. Results are filtered at adj. p ≤ 0.05
        and ranked by |logFC|; we keep the top 50 per cluster. If a neighbor graph is missing, we compute PCA and
        <code>pp.neighbors</code> on the fly, or gracefully fall back to cluster-vs-rest if too few clusters exist.
      </p>

      <h5 class="mt-3">Cell-type prediction (enrichment)</h5>
      <p class="mb-2">
        We score cell-type signatures with <strong>decoupler</strong>’s ULM method against a curated
        <strong>PanglaoDB</strong> marker resource (human entries, canonical markers only, sensitivity &gt; 0.5,
        duplicates removed). ULM scores are computed per cell (<code>dc.mt.ulm</code>, <code>tmin=3</code>),
        then summarized per cluster using <code>rankby_group</code> (t-test with overestimated variance);
        only positive-stat entries are kept. The “Predicted annotation” tab shows (i) a UMAP colored by per-cell
        enrichment for the selected cell type and (ii) per-cluster score distributions. We list the top 5 candidate
        cell types per cluster as suggestions, not hard labels.
      </p>

      <h5 class="mt-3">Transcription-factor programs</h5>
      <p class="mb-2">
        TF activity is estimated with decoupler ULM using the human <strong>CollecTRI</strong> regulon network.
        We compute per-cell TF scores, then rank TFs per cluster (same statistics as above) and retain the top 5 TFs
        as “program markers.” The TF tab shows a UMAP of the selected TF’s activity and a violin panel with
        cluster-wise distributions.
      </p>

      <h5 class="mt-3">Co-expression &amp; gene-set analysis</h5>
      <p class="mb-2">
        <strong>Co-expression:</strong> given Gene A and Gene B, cells are colored either (a) in
        <em>bivariate</em> mode using independent quantile thresholds for A and B
        (A-high, B-high, both-high, low) or (b) in <em>ratio</em> mode using A/B (or log<sub>2</sub>(A/B)).
        Controls include per-gene clipping to upper quantiles, binarization, a global scale option, and an
        Otsu-based auto-threshold “Suggest” button for each gene. An auxiliary table lists cells with the most
        extreme A/B ratios.
      </p>
      <p class="mb-2">
        <strong>Gene-set scoring:</strong> the “Signature” panel computes a per-cell mean Z-score across the
        pasted gene list (each gene is Z-scored across cells; the signature score is their mean).
        The resulting score is rendered on UMAP and also registered as a virtual gene so it can be reused elsewhere
        in the dashboard.
      </p>

      <h5 class="mt-3">AI insights — optional</h5>
      <p class="mb-2">
        If enabled at build time (“Generate biology insights”), we produce cluster-wise narrative summaries with a
        large language model (Gemini family with automatic fallbacks). <em>Only</em> cluster-level summaries are
        provided to the model: cluster sizes; neighborhood-aware markers; method-specific marker tables; the
        per-cluster PanglaoDB enrichment ranks; and the top TFs. Raw counts or per-cell expression matrices are
        <em>not</em> sent. The model returns concise Markdown with a proposed label (± a refined subtype),
        confidence (High/Medium/Low), and supporting markers. Treat AI text as suggestive and validate against
        the Markers, Predicted annotation, and TF tabs.
      </p>

      <details class="mt-2">
        <summary class="small text-muted">Show general AI prompt</summary>
        <pre class="legal-pre small">ROLE
You are “GeneSage,” a PhD-level molecular biologist and single-cell bioinformatics specialist.

OBJECTIVE
Predict the most likely cell type for {leiden} cluster {cluster} in dataset {dataset_name} using ONLY the inputs provided.

INPUTS
Cluster size: {size}
{top_marker_lines}
Additional marker genes per method (JSON): {cl_markers}
Cell-type enrichment from PanglaoDB (CSV): {cl_ctype_csv}
Tissue context: {tissue_context}

OUTPUT
Return a concise markdown paragraph with the canonical label, an optional fine
label, confidence (High/Medium/Low), and key markers supporting the call.</pre>
      </details>

      <p class="small text-muted mt-3 mb-0">
        Rendering notes: expression vectors are quantized for sparsity-aware transport and colored with a
        grey→rainbow palette; QC and composition views reflect the currently selected <code>layer</code>.
      </p>
    </div>
  </div>
  <div id="about" class="tabpane">
  <div class="about-hero card shadow-sm p-4 mb-4">
    <div class="d-flex align-items-center gap-3 mb-3">
      <svg class="logoSVG" style="max-width:140px;" viewBox="0 0 400 250" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="STREAM logo"><use href="#logoSymbol"/></svg>
      <div>
        <h3 class="mb-1">STREAM</h3>
        <div class="text-muted">Streamlined Toolkit for Real-time Exploratory Analysis of Multiomics</div>
      </div>
    </div>

    <!-- Expanded product sentence (requested) -->
    <p class="lead mb-2">
      Interactive data mining and analysis of bulk and single-cell expression data —
      delivered as a fast, shareable HTML dashboard with UMAPs, marker discovery,
      enrichment, transcription factor activity, and co-expression exploration.
    </p>

    <!-- Mission (requested: accessibility + data mining help) -->
    <ul class="about-mission mb-0">
      <li><strong>Accessible bioinformatics:</strong> zero-install, point-and-click dashboards that work offline.</li>
      <li><strong>Ai assisted annotation:</strong> LLM-assisted, cluster-wise summaries with transparent prompts & inputs.</li>
      <li><strong>Faster insights:</strong> opinionated defaults for QC, markers, enrichment and TF activity to speed up data mining.</li>
      <li><strong>Reproducible & transparent:</strong> embedded metadata, versioned templates, and explicit sources for enrichment.</li>
      <li><strong>Shareable results:</strong> a single HTML file you can send to collaborators or attach to a preprint.</li>
    </ul>
  </div>

  <div class="row g-3 about-grid">
    <!-- Toolkit overview (concise) -->
    <div class="col-lg-6">
      <div class="card h-100 p-4">
        <h5 class="mb-3">About the toolkit</h5>
        <ul class="list-unstyled small mb-0">
          <li class="mb-2"><span class="badge bg-light text-dark border me-2">QC</span> gating, batch view, per-cluster summaries</li>
          <li class="mb-2"><span class="badge bg-light text-dark border me-2">Markers</span> Wilcoxon / t-test + neighborhood-aware markers</li>
          <li class="mb-2"><span class="badge bg-light text-dark border me-2">Enrichment</span> PanglaoDB-based cell-type scoring</li>
          <li class="mb-2"><span class="badge bg-light text-dark border me-2">TF</span> CollecTRI ULM programs per cluster</li>
          <li class="mb-2"><span class="badge bg-light text-dark border me-2">Co-expression</span> bivariate & ratio modes with contours</li>
          <li><span class="badge bg-light text-dark border me-2">Insights</span> optional AI-assisted, cluster-wise summaries</li>
        </ul>
      </div>
    </div>

    <!-- Dataset metadata (clear, compact) -->
    <div class="col-lg-6">
      <div class="card h-100 p-4">
        <h5 class="mb-3">About this dataset</h5>
        <dl class="about-kv">
          <dt>Dataset</dt>     <dd id="about-ds">§DATA_NAME</dd>
          <dt>Layer</dt>       <dd id="about-layer">§LAYER</dd>
          <dt>Cells</dt>       <dd id="about-cells">–</dd>   <!-- filled by JS -->
          <dt>Generated</dt>   <dd>§GENERATED</dd>
          <dt>Version</dt>     <dd>2.0</dd>
        </dl>
        <div class="small text-muted mt-2">
          Notes: values shown reflect the current HTML build; analyses respect the selected layer.
        </div>
      </div>
    </div>

    <!-- People & support -->
    <div class="col-lg-6">
      <div class="card h-100 p-4">
        <h5 class="mb-3">Contributors</h5>
        <ul class="list-unstyled mb-0">
          <li>
            Victor Barozi —
            <a href="mailto:V.Barozi@soton.ac.uk">V.Barozi@soton.ac.uk</a>
          </li>
          <li>
            Andres F. Vallejo —
            <a href="mailto:afvp1f17@soton.ac.uk">afvp1f17@soton.ac.uk</a>
          </li>
        </ul>
      </div>
    </div>

    <div class="col-lg-6">
      <div class="card h-100 p-4">
        <h5 class="mb-3">Support & Acknowledgements</h5>
        <p class="mb-2">Single Cell MultiOmics Lab</p>
      <p class="small mb-0">
        If you use STREAM in your work, please cite:
        <em>STREAM (v2.0) — Streamlined Toolkit for Real-time Exploratory Analysis of Multiomics, generated §GENERATED.</em>
      </p>
    </div>
  </div>

      <!-- Legal & Licensing -->
      <div class="col-12">
        <div class="card h-100 p-4">
          <h5 class="mb-2">Legal & Licensing</h5>

          <!-- Disclaimer -->
          <div class="small">
            <p class="mb-2"><strong>Disclaimer.</strong> STREAM is a research and education tool. It is not intended for clinical, diagnostic, or patient-management decisions.</p>
            <ul class="mb-2">
              <li><strong>AI Insights (if enabled)</strong> are LLM-generated summaries that can be incomplete or incorrect; always validate with markers, enrichment and TF activity.</li>
              <li><strong>Privacy.</strong> This dashboard does not upload sample-level data to a server; rendering happens in your browser. (If you need strict offline use, bundle local JS/CSS assets instead of CDNs.)</li>
              <li><strong>Upstream AI usage.</strong> If you tick “Generate biology insights” during build, cluster-level summaries (markers, enrichment ranks, etc.) are sent to the configured AI provider to produce text; raw counts are not sent.</li>
              <li><strong>No warranty.</strong> Provided “AS IS” without warranty of any kind; you are responsible for verifying results and for compliance with any data-use terms.</li>
            </ul>
          </div>

          <!-- Licenses -->
          <div class="small">
            <div class="mb-1"><strong>STREAM code license:</strong> <span id="toolLicense">§TOOL_LICENSE</span></div>
            <div><strong>Dataset licence:</strong> <span id="dataLicense">§DATA_LICENSE</span></div>
          </div>

          <!-- Full license text (MIT by default) -->
          <details class="mt-2">
            <summary class="small text-muted">Show full STREAM license</summary>
            <pre class="legal-pre small">MIT License

Copyright (c) 2025 Single Cell MultiOmics Lab / STREAM Authors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the “Software”), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</pre>
          </details>
        </div>
      </div>
  </div>

</div>
<div id="globalFooter" class="text-end">
  <div class="about-tagline">
    <span class="about-dot"></span>
    <span class="about-dot"></span>
    <span class="about-dot"></span>
    <span class="about-text">Make your omics flow</span>
  </div>
  <div class="small text-muted">
    See <a href="#about" onclick="setHash('about');">Legal & Licensing</a>.
  </div>
</div>
<div id="helpOverlay">
  <button type="button" class="btn-close help-close"></button>
  <div id="helpContent"></div>
  <button id="startTourBtn" class="btn btn-sm btn-primary mt-3">Start tour</button>
</div>
<div id="helpBackdrop"></div>
<div id="tourOverlay"><div><p id="tourText"></p><button id="tourNext" class="btn btn-sm btn-light mt-3">Next</button></div></div>
<script>
function inflateExp(b64){
  const bin = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
  return JSON.parse(pako.inflate(bin, {to:'string'}));
}
function inflateArray(b64, ctor){
  const bin = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
  return new ctor(pako.inflate(bin).buffer);
}
const EXP   = inflateExp(§EXP);
const GENES = inflateExp(§GENES);
const CMAP  = §CMAP;
const COLORBAR = {len:0.6, thickness:10};
const VMIN  = inflateArray(§VMIN, Float32Array);
const VMAX  = inflateArray(§VMAX, Float32Array);
const PROT_EXP   = inflateExp(§PROT_EXP);
const PROT_GENES = inflateExp(§PROT_GENES);
const PROT_VMIN  = inflateArray(§PROT_VMIN, Float32Array);
const PROT_VMAX  = inflateArray(§PROT_VMAX, Float32Array);
const PROT_INDEX = Object.fromEntries(PROT_GENES.map((g,i)=>[g,i]));
const CELLS = inflateExp(§CELLS);
const NCELLS = CELLS.length;
const DOM = "§DOM";
const MARKERS = inflateExp(§MARKERS);
const TOP_MARKERS = inflateExp(§TOP_MARKERS);
const HAS_PROT = PROT_GENES.length > 0 && MARKERS.Protein !== undefined;
let CURRENT_MODALITY = 'RNA';
const markerClusterByMod = {};
const topMarkerClusterByMod = {};
let umapObsGeneConfirmed = false;
const CTYPES = inflateExp(§CTYPES);
const ENRICH = Object.fromEntries(
  Object.entries(§ENRICH).map(([k,o])=>[k,{ data: inflateArray(o.data, Uint8Array), vmin:o.vmin, vmax:o.vmax }])
);
const NCOUNTS = §NCOUNTS?inflateArray(§NCOUNTS, Float32Array):null;
const NGENES = §NGENES?inflateArray(§NGENES, Float32Array):null;
const PCT_MT = §PCT_MT?inflateArray(§PCT_MT, Float32Array):null;
const PCT_RIBO = §PCT_RIBO?inflateArray(§PCT_RIBO, Float32Array):null;
const DBL_SCORE = §DBL_SCORE?inflateArray(§DBL_SCORE, Float32Array):null;
const BATCH = §BATCH;
const CELL_CYCLE = §CELL_CYCLE;
const NN_INDPTR = §NN_INDPTR?inflateArray(§NN_INDPTR, Int32Array):null;
const NN_INDICES = §NN_INDICES?inflateArray(§NN_INDICES, Int32Array):null;
function getEnrichFloat(sig){
  const o = ENRICH[sig]; if(!o) return new Float32Array(NCELLS);
  const out = new Float32Array(NCELLS);
  const rng = Math.max(o.vmax - o.vmin, 1e-6);
  for(let i=0;i<out.length;i++) out[i] = o.vmin + (o.data[i]/255)*rng;
  return out;
}
const LEIDEN = §LEIDEN;
const UMAP_X = inflateArray(§UMAP_X, Float32Array);
const UMAP_Y = inflateArray(§UMAP_Y, Float32Array);
const UMAP_X_MIN = Math.min(...UMAP_X), UMAP_X_MAX = Math.max(...UMAP_X);
const UMAP_Y_MIN = Math.min(...UMAP_Y), UMAP_Y_MAX = Math.max(...UMAP_Y);
const UMAP_SPAN = Math.max(UMAP_X_MAX-UMAP_X_MIN, UMAP_Y_MAX-UMAP_Y_MIN);
const UMAP_XRANGE = [(UMAP_X_MIN+UMAP_X_MAX)/2 - UMAP_SPAN/2,
                     (UMAP_X_MIN+UMAP_X_MAX)/2 + UMAP_SPAN/2];
const UMAP_YRANGE = [(UMAP_Y_MIN+UMAP_Y_MAX)/2 - UMAP_SPAN/2,
                     (UMAP_Y_MIN+UMAP_Y_MAX)/2 + UMAP_SPAN/2];
const CLUSTER_CODES = inflateArray(§CLUSTER_CODES, Uint16Array);
const CLUSTER_NAMES = inflateExp(§CLUSTER_NAMES);
const CLUSTERS = CLUSTER_NAMES;
const CLUSTER_COLORS_MAP = typeof §CLUSTER_COLORS_MAP !== 'undefined' ? §CLUSTER_COLORS_MAP : null;
const CLUSTER_COLORS = CLUSTER_COLORS_MAP
  ? CLUSTER_NAMES.reduce((acc,c)=>{ acc[c]=CLUSTER_COLORS_MAP[c]||'#666'; return acc; },{})
  : Object.fromEntries(CLUSTER_NAMES.map((c,i)=>[c,`hsl(${(360*i)/Math.max(CLUSTERS.length,1)},65%,50%)`]));
const CLUSTER_PTS = Array.from({length: CLUSTERS.length}, () => ({xs: [], ys: []}));
for(let i=0;i<NCELLS;i++){
  const ci=CLUSTER_CODES[i];
  if(ci>=CLUSTERS.length)continue;
  const p=CLUSTER_PTS[ci];
  p.xs.push(UMAP_X[i]);
  p.ys.push(UMAP_Y[i]);
}
const CLUSTER_COUNTS = inflateExp(§CLUSTER_COUNTS);
const BIOLOGY_INFO = inflateExp(§BIOLOGY_INFO);
const CLUSTER_INDEX = Object.fromEntries(CLUSTER_NAMES.map((c,i)=>[c,i]));
const GENE_INDEX = Object.fromEntries(GENES.map((g,i)=>[g,i]));
const L_LEFT_POINT_SIZE = 5;
const L_LEFT_POINT_OPACITY = 0.9;

const COMPOSITION = §COMPOSITION;
const OBS_CATS = §OBS_CATS;
const OBS_LEVELS = §OBS_LEVELS;
const OBS_COLORS = §OBS_COLORS;
const SAMPLE_KEY = §SAMPLE_KEY;
const DIRICHLET = §DIRICHLET;
const OBS_COL_MATRIX = Object.fromEntries(
  Object.entries(§OBS_COL_MATRIX||{}).map(([k,v])=>[k, inflateArray(v, Uint16Array)])
);
if(COMPOSITION){
  COMPOSITION.counts = inflateArray(COMPOSITION.counts, Int32Array);
  COMPOSITION.props = inflateArray(COMPOSITION.props, Float32Array);
}

const VOLCANO_DATA = VOLCANO_DATA_PLACEHOLDER;
const VOLCANO_CELLTYPES = VOLCANO_CELLTYPES_PLACEHOLDER;
const DGE_DATA = DGE_DATA_PLACEHOLDER;
const DGE_CELLTYPES = DGE_CELLTYPES_PLACEHOLDER;
const TF_BARPLOTS = TF_BARPLOTS_PLACEHOLDER;
const TF_CELLTYPES = TF_CELLTYPES_PLACEHOLDER;

const EXP_CACHE = new Map();
const MAX_CACHE = 50;
const PERC_CACHE = new Map();
const PSEUDOCOUNT = 0.000001;

// QC helpers --------------------------------------------------------------
const QC_METRICS = {
  n_counts: NCOUNTS,
  n_genes: NGENES,
  pct_counts_mt: PCT_MT,
  pct_counts_ribo: PCT_RIBO,
  doublet_score: DBL_SCORE
};

const QC_STATE = {
  thresholds: {
    pct_counts_mt: [0, 100],
    pct_counts_ribo: [0, 100],
    n_counts: [0, Infinity],
    n_genes: [0, Infinity],
    doublet_score: [0, 1]
  },
  pass: new Uint8Array(NCELLS).fill(1)
};

function qcApplyGates(){
  const mt = QC_METRICS.pct_counts_mt;
  const ribo = QC_METRICS.pct_counts_ribo;
  const ncounts = QC_METRICS.n_counts;
  const ngenes = QC_METRICS.n_genes;
  const dbl = QC_METRICS.doublet_score;
  for(let i=0;i<NCELLS;i++){
    let ok = true;
    if(mt) ok = ok && mt[i] <= QC_STATE.thresholds.pct_counts_mt[1];
    if(ribo) ok = ok && ribo[i] <= QC_STATE.thresholds.pct_counts_ribo[1];
    if(ncounts) ok = ok && ncounts[i] >= QC_STATE.thresholds.n_counts[0] && ncounts[i] <= QC_STATE.thresholds.n_counts[1];
    if(ngenes) ok = ok && ngenes[i] >= QC_STATE.thresholds.n_genes[0] && ngenes[i] <= QC_STATE.thresholds.n_genes[1];
    if(dbl) ok = ok && dbl[i] <= QC_STATE.thresholds.doublet_score[1];
    QC_STATE.pass[i] = ok ? 1 : 0;
  }
}

function qcPercentile(arr, q){
  const v = Array.from(arr).filter(x=>Number.isFinite(x)).sort((a,b)=>a-b);
  if(v.length===0) return NaN;
  const idx = Math.min(v.length-1, Math.max(0, Math.floor(q*(v.length-1))));
  return v[idx];
}

function drawQCOverview(metric){
  const arr = QC_METRICS[metric];
  if(!arr) return;
  const pass = QC_STATE.pass;
  const min = qcPercentile(arr, 0.01);
  const max = qcPercentile(arr, 0.99);
  const passX=[],passY=[],passVal=[],passHover=[],failX=[],failY=[],failHover=[];
  for(let i=0;i<NCELLS;i++){
    const hover = `${CELLS[i]}<br>cluster:${CLUSTER_NAMES[CLUSTER_CODES[i]]}${BATCH?`<br>batch:${BATCH[i]}`:''}<br>${metric}:${arr[i].toFixed(2)}`;
    if(pass[i]){passX.push(UMAP_X[i]);passY.push(UMAP_Y[i]);passVal.push(arr[i]);passHover.push(hover);}else{failX.push(UMAP_X[i]);failY.push(UMAP_Y[i]);failHover.push(hover);}
  }
  const tracePass={x:passX,y:passY,text:passHover,hovertemplate:'%{text}<extra></extra>',mode:'markers',type:'scattergl',marker:{color:passVal,colorscale:'Viridis',cmin:min,cmax:max,size:5,opacity:0.8,colorbar:{...COLORBAR,title:metric}},showscale:true};
  const traceFail={x:failX,y:failY,text:failHover,hovertemplate:'%{text}<extra></extra>',mode:'markers',type:'scattergl',marker:{color:'rgba(200,200,200,0.3)',size:5}};
  Plotly.newPlot('qc_umap',[traceFail,tracePass],{margin:{l:10,r:10,t:30,b:10},xaxis:{visible:false,scaleanchor:'y'},yaxis:{visible:false},hovermode:'closest',title:metric},{responsive:true});
  Plotly.newPlot('qc_hist',[{x:Array.from(arr),type:'histogram',nbinsx:40,marker:{color:'#0d6efd'}}],{margin:{l:40,r:10,t:30,b:40},title:metric},{responsive:true});
}

function updateQCSummary(){
  const pass = QC_STATE.pass;
  let passCount=0;
  const metrics = ['n_counts','n_genes','pct_counts_mt','pct_counts_ribo','doublet_score'];
  const med = {};
  const arrays={n_counts:NCOUNTS,n_genes:NGENES,pct_counts_mt:PCT_MT,pct_counts_ribo:PCT_RIBO,doublet_score:DBL_SCORE};
  const vals={};
  metrics.forEach(m=>{vals[m]=[];});
  for(let i=0;i<NCELLS;i++){
    if(pass[i]){
      passCount++;
      metrics.forEach(m=>{const arr=arrays[m]; if(arr) vals[m].push(arr[i]);});
    }
  }
  function median(a){if(a.length===0) return NaN; a.sort((x,y)=>x-y); return a[Math.floor(a.length/2)];}
  metrics.forEach(m=>{med[m]=median(vals[m]);});
  const fail = NCELLS - passCount;
  const pct = ((passCount/NCELLS)*100).toFixed(1);
  let html='<table class="table table-sm"><thead><tr><th>Total cells</th><th>Pass</th><th>Fail</th><th>% Pass</th><th>Median nUMIs</th><th>Median nGenes</th><th>Median %MT</th><th>Median %Ribo</th><th>Median Doublet</th></tr></thead><tbody>';
  html+=`<tr><td>${NCELLS}</td><td>${passCount}</td><td>${fail}</td><td>${pct}</td><td>${isNaN(med.n_counts)?'NA':med.n_counts.toFixed(1)}</td><td>${isNaN(med.n_genes)?'NA':med.n_genes.toFixed(1)}</td><td>${isNaN(med.pct_counts_mt)?'NA':med.pct_counts_mt.toFixed(2)}</td><td>${isNaN(med.pct_counts_ribo)?'NA':med.pct_counts_ribo.toFixed(2)}</td><td>${isNaN(med.doublet_score)?'NA':med.doublet_score.toFixed(2)}</td></tr>`;
  html+='</tbody></table>';
  document.getElementById('qc_summary').innerHTML = html;
}

  function initQCOverview(){
    qcOverviewPurged=false;
    const metricInfo=[
    {k:'n_counts',label:'nUMIs'},
    {k:'n_genes',label:'nGenes'},
    {k:'pct_counts_mt',label:'% MT'},
    {k:'pct_counts_ribo',label:'% Ribo'},
    {k:'doublet_score',label:'Doublet score'}
  ];
  const btns = document.getElementById('qc_metric_buttons');
  let defaultMetric=null;
  metricInfo.forEach(m=>{
    if(QC_METRICS[m.k]){
      const b=document.createElement('button');
      b.className='btn btn-sm btn-outline-primary me-1 qc-metric';
      b.textContent=m.label; b.dataset.metric=m.k;
      btns.appendChild(b);
      if(!defaultMetric) defaultMetric=m.k;
    } else {
      const span=document.createElement('span'); span.className='badge bg-warning text-dark me-1'; span.textContent=`${m.label} unavailable`; btns.appendChild(span);
    }
  });
  btns.addEventListener('click',e=>{
    const t=e.target.closest('button.qc-metric');
    if(!t) return;
    btns.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
    t.classList.add('active');
    currentMetric = t.dataset.metric;
    drawQCOverview(currentMetric);
  });
  // gating controls
  const gates=document.getElementById('qc_gates');
  function gateInput(id,label,def,min,max,step){const div=document.createElement('div');div.className='mb-2';div.innerHTML=`<label class="form-label">${label}</label><input type="number" id="${id}" class="form-control form-control-sm" value="${def}" data-default="${def}" min="${min}" max="${max}" step="${step}">`;gates.appendChild(div);} 
  if(PCT_MT) gateInput('gate_mt','% MT max',100,0,100,0.1);
  if(PCT_RIBO) gateInput('gate_ribo','% Ribo max',100,0,100,0.1);
  if(NCOUNTS) {gateInput('gate_ncounts_min','nUMIs min',0,0,1e9,1); gateInput('gate_ncounts_max','nUMIs max',1e9,0,1e9,1);} 
  if(NGENES) {gateInput('gate_ngenes_min','nGenes min',0,0,1e9,1); gateInput('gate_ngenes_max','nGenes max',1e9,0,1e9,1);} 
  if(DBL_SCORE) gateInput('gate_dbl','Doublet max',1,0,1,0.01);
  const btnWrap=document.createElement('div');
  btnWrap.className='d-flex gap-2';
  btnWrap.innerHTML='<button id="qc_apply" class="btn btn-sm btn-primary">Apply gates</button><button id="qc_reset" class="btn btn-sm btn-secondary">Reset</button>';
  gates.appendChild(btnWrap);
  document.getElementById('qc_apply').addEventListener('click',()=>{
    if(PCT_MT) QC_STATE.thresholds.pct_counts_mt[1]=parseFloat(document.getElementById('gate_mt').value)||100;
    if(PCT_RIBO) QC_STATE.thresholds.pct_counts_ribo[1]=parseFloat(document.getElementById('gate_ribo').value)||100;
    if(NCOUNTS){QC_STATE.thresholds.n_counts[0]=parseFloat(document.getElementById('gate_ncounts_min').value)||0;QC_STATE.thresholds.n_counts[1]=parseFloat(document.getElementById('gate_ncounts_max').value)||Infinity;}
    if(NGENES){QC_STATE.thresholds.n_genes[0]=parseFloat(document.getElementById('gate_ngenes_min').value)||0;QC_STATE.thresholds.n_genes[1]=parseFloat(document.getElementById('gate_ngenes_max').value)||Infinity;}
    if(DBL_SCORE) QC_STATE.thresholds.doublet_score[1]=parseFloat(document.getElementById('gate_dbl').value)||1;
    qcApplyGates();
    drawQCOverview(currentMetric);
    updateQCSummary();
    if(qcPerClusterInit) renderQCPerCluster();
  });
  document.getElementById('qc_reset').addEventListener('click',()=>{
    Object.assign(QC_STATE.thresholds,{pct_counts_mt:[0,100],pct_counts_ribo:[0,100],n_counts:[0,Infinity],n_genes:[0,Infinity],doublet_score:[0,1]});
    gates.querySelectorAll('input').forEach(inp=>{const d=inp.dataset.default; inp.value=d;});
    qcApplyGates(); drawQCOverview(currentMetric); updateQCSummary(); if(qcPerClusterInit) renderQCPerCluster();
  });
  let currentMetric=defaultMetric;
  qcApplyGates();
  if(defaultMetric){
    btns.querySelector(`button[data-metric="${defaultMetric}"]`).classList.add('active');
    drawQCOverview(defaultMetric);
    updateQCSummary();
  }
}

function renderQCPerCluster(){
  qcPerClusterPurged=false;
  const sel=document.getElementById('qc_cluster_sel');
  const showAll=document.getElementById('qc_show_all');
  if(sel.options.length===0){
    CLUSTER_NAMES.forEach((n,i)=>{const opt=document.createElement('option');opt.value=i;opt.textContent=n;sel.appendChild(opt);});
  }
  function median(a){if(a.length===0) return NaN; a.sort((x,y)=>x-y); const m=Math.floor(a.length/2); return a.length%2?a[m]:(a[m-1]+a[m])/2;}
  function update(){
    const clusters=showAll.checked?CLUSTER_NAMES.map((_,i)=>i):[parseInt(sel.value)];
    const metrics=Object.entries(QC_METRICS).filter(([k,v])=>v);
    const container=document.getElementById('qc_violin');
    container.innerHTML='';
    metrics.forEach(([key,arr])=>{
      const div=document.createElement('div');
      div.style.width='100%';div.style.height='300px';
      container.appendChild(div);
      const traces=[];
        clusters.forEach(ci=>{
          const all=[],pass=[];
          for(let i=0;i<NCELLS;i++){
            if(CLUSTER_CODES[i]===ci){
              const v=arr[i]+PSEUDOCOUNT;
              if(!isNaN(v)){
                all.push(v);
                if(QC_STATE.pass[i]) pass.push(v);
              }
            }
          }
          if(all.length) traces.push({type:'violin',y:all,x:Array(all.length).fill(CLUSTER_NAMES[ci]),name:CLUSTER_NAMES[ci]+' all',line:{color:'rgba(0,0,0,0.3)'},opacity:0.3,box:{visible:true},showlegend:false});
          if(pass.length) traces.push({type:'violin',y:pass,x:Array(pass.length).fill(CLUSTER_NAMES[ci]),name:CLUSTER_NAMES[ci],line:{color:'#0d6efd'},opacity:1,box:{visible:true},showlegend:false});
        });
      Plotly.newPlot(div,traces,{margin:{l:40,r:10,t:30,b:40},yaxis:{title:key},xaxis:{title:LEIDEN,automargin:true},title:key.replace(/_/g,' ')},{responsive:true});
    });
    let html='<table class="table table-sm table-hover"><thead><tr><th>'+LEIDEN+'</th><th>n_cells</th><th>n_pass</th><th>% pass</th>';
    metrics.forEach(([key])=>{html+='<th>'+key+'</th>';});
    html+='</tr></thead><tbody>';
    clusters.forEach(ci=>{
      let n_cells=0,n_pass=0; const metricVals={}; metrics.forEach(([k])=>{metricVals[k]=[];});
      for(let i=0;i<NCELLS;i++){
        if(CLUSTER_CODES[i]===ci){
          n_cells++;
          if(QC_STATE.pass[i]){
            n_pass++;
            metrics.forEach(([k,arr])=>{const v=arr[i]; if(!isNaN(v)) metricVals[k].push(v);});
          }
        }
      }
      html+='<tr><td>'+CLUSTER_NAMES[ci]+'</td><td>'+n_cells+'</td><td>'+n_pass+'</td><td>'+(n_cells?(100*n_pass/n_cells).toFixed(1):'0.0')+'</td>';
      metrics.forEach(([k])=>{const vals=metricVals[k]; html+='<td>'+(vals.length?median(vals).toFixed(1):'NA')+'</td>';});
      html+='</tr>';
    });
    html+='</tbody></table>';
    document.getElementById('qc_cluster_table').innerHTML=html;
  }
  sel.onchange=update;
  showAll.onchange=update;
  update();
}

function renderBatchIntegration(){
  if(!BATCH || (new Set(BATCH)).size<=1){
    document.getElementById('qc_batch_umap').textContent='Batch diagnostics disabled (single batch)';
    return;
  }
  const hover=BATCH.map((b,i)=>`${CELLS[i]}<br>batch:${b}`);
  const trace={x:UMAP_X,y:UMAP_Y,text:hover,hovertemplate:'%{text}<extra></extra>',mode:'markers',type:'scattergl',marker:{color:BATCH.map(b=>CLUSTER_COLORS[b]||'#333'),size:5}};
  Plotly.newPlot('qc_batch_umap',[trace],{margin:{l:10,r:10,t:30,b:10},xaxis:{visible:false,scaleanchor:'y'},yaxis:{visible:false}}, {responsive:true});
  document.getElementById('qc_batch_table').textContent='Batch composition table not implemented.';
}

function aggregateCounts(sampleKey, groupby){
  const sampleIndex = OBS_COL_MATRIX[sampleKey];
  const groupIndex = OBS_COL_MATRIX[groupby];
  const sampleLabels = OBS_LEVELS[sampleKey]||[];
  const levels = OBS_LEVELS[groupby]||[];
  const nSamples = sampleLabels.length;
  const nGroups = levels.length;
  const counts = new Int32Array(nSamples * nGroups);
  if(!sampleIndex || !groupIndex) return {counts, props:new Float32Array(nSamples*nGroups), sample_labels:sampleLabels, group_labels:levels, n_groups:nGroups};
  for(let i=0;i<sampleIndex.length;i++){
    const r=sampleIndex[i], c=groupIndex[i];
    if(r>=0 && r<nSamples && c>=0 && c<nGroups) counts[r*nGroups+c]++;
  }
  const props = new Float32Array(nSamples * nGroups);
  for(let r=0;r<nSamples;r++){
    let rowSum=0;
    for(let c=0;c<nGroups;c++) rowSum+=counts[r*nGroups+c];
    const denom=rowSum>0?rowSum:1;
    for(let c=0;c<nGroups;c++) props[r*nGroups+c]=counts[r*nGroups+c]/denom;
  }
  return {counts, props, sample_labels:sampleLabels, group_labels:levels, n_groups:nGroups};
}

function getGroupColors(groupby, levels){
  const m = OBS_COLORS[groupby];
  if(m){return levels.map(l=>m[l]);}
  return levels.map((_,i)=>`hsl(${(360*i)/Math.max(levels.length,1)},65%,50%)`);
}

let currentAgg=null;

function renderComposition(){
  const sampleKey = $('#compSampleKey').val();
  const groupby = $('#compGroupBy').val();
  if(sampleKey===COMPOSITION.sample_key && groupby===COMPOSITION.groupby){
    currentAgg={counts:COMPOSITION.counts, props:COMPOSITION.props, sample_labels:COMPOSITION.sample_labels, group_labels:COMPOSITION.group_labels, n_groups:COMPOSITION.n_groups};
  }else{
    currentAgg=aggregateCounts(sampleKey, groupby);
  }
  const sampleLabels = currentAgg.sample_labels;
  const {counts, props, group_labels} = currentAgg;
  const norm = $('#compNorm').val();
  const mode = $('#compBarType').val();
  const nSamples = sampleLabels.length;
  const nGroups = group_labels.length;
  const countsMat=[], propsMat=[];
  for(let r=0;r<nSamples;r++){
    const cr=[], pr=[];
    for(let c=0;c<nGroups;c++){cr.push(counts[r*nGroups+c]); pr.push(props[r*nGroups+c]);}
    countsMat.push(cr); propsMat.push(pr);
  }
  const dataMat = norm==='props'?propsMat:countsMat;
  const traces=[];
  if(mode==='group'){
    const colors=getGroupColors(sampleKey, sampleLabels);
    for(let r=0;r<nSamples;r++){
      const x=group_labels;
      const y=dataMat[r];
      const hover=group_labels.map((g,c)=>`${g}<br>${sampleLabels[r]}<br>count:${countsMat[r][c]}<br>prop:${(propsMat[r][c]*100).toFixed(1)}%`);
      const marker={color:colors[r]};
      traces.push({type:'bar',name:sampleLabels[r],x,y,text:hover,textposition:'none',hovertemplate:'%{text}<extra></extra>',marker});
    }
  }else{
    const colors=getGroupColors(groupby, group_labels);
    for(let c=0;c<nGroups;c++){
      const y=dataMat.map(row=>row[c]);
      const hover=sampleLabels.map((s,r)=>`${s}<br>${group_labels[c]}<br>count:${countsMat[r][c]}<br>prop:${(propsMat[r][c]*100).toFixed(1)}%`);
      const marker={color:colors[c]};
      traces.push({type:'bar',name:group_labels[c],x:sampleLabels,y,text:hover,textposition:'none',hovertemplate:'%{text}<extra></extra>',marker});
    }
  }
  Plotly.newPlot('compBar', traces, {
    ...PLOTLY_THEME.layout,
    margin:{l:40,r:10,t:30,b:40},
    barmode:mode,
    xaxis:{automargin:true},
    yaxis:{title:norm==='props'?'Proportion':'Count',automargin:true,rangemode:'tozero'}
  }, PLOTLY_THEME.config);
  let html='<thead><tr><th>'+sampleKey+'</th>';
  group_labels.forEach(g=>html+='<th>'+g+'</th>');
  html+='</tr></thead><tbody>';
  for(let r=0;r<nSamples;r++){
    html+='<tr><td>'+sampleLabels[r]+'</td>';
    for(let c=0;c<nGroups;c++) html+='<td>'+countsMat[r][c]+'</td>';
    html+='</tr>';
  }
  html+='</tbody>';
  const tbl=$('#compTable').html(html);
  if($.fn.DataTable){if(tbl.hasClass('dataTable')) tbl.DataTable().destroy(); tbl.DataTable({paging:false,searching:false,info:false});}
}

function downloadCompositionCSV(type){
  if(!currentAgg) return;
  const nSamples=currentAgg.sample_labels.length;
  const nGroups=currentAgg.group_labels.length;
  const header=$('#compSampleKey').val();
  let csv=header+','+currentAgg.group_labels.join(',')+'\n';
  for(let r=0;r<nSamples;r++){
    const row=[];
    for(let c=0;c<nGroups;c++){
      row.push(type==='props'?currentAgg.props[r*nGroups+c]:currentAgg.counts[r*nGroups+c]);
    }
    csv+=currentAgg.sample_labels[r]+','+row.join(',')+'\n';
  }
  const blob=new Blob([csv],{type:'text/csv'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download=type==='props'?'composition_proportions.csv':'composition_counts.csv';
  a.click();
}

function downloadTableCSV(filename, rows){
  const csv = rows.map(r => r.map(v => `"${String(v).replace(/"/g,'""')}"`).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
}

function downloadEnrichCSV(){
  const rows = [['cluster','rank','cell_type']];
  Object.entries(CTYPES).forEach(([cl, types]) => {
    (types||[]).forEach((t,i) => rows.push([cl, i+1, t]));
  });
  downloadTableCSV('predicted_annotation.csv', rows);
}

function renderDirichlet(){
  if(!DIRICHLET||!DIRICHLET.length) return;
  $('#dirichletPanel').show();
  const y = DIRICHLET.map(d=>`${d.compartment} • ${d.variable}`);
  const x = DIRICHLET.map(d=>d.coefficient);
  const err = DIRICHLET.map(d=>1.96*d.se);
  Plotly.newPlot('dirichletForest',[{type:'scatter',mode:'markers',x,y,error_x:{type:'data',array:err,visible:true},hovertemplate:'%{y}<br>coef:%{x:.3f}<extra></extra>'}],{...PLOTLY_THEME.layout,xaxis:{title:'Coefficient'},yaxis:{automargin:true}},PLOTLY_THEME.config);
  let html='<thead><tr><th>compartment</th><th>variable</th><th>coefficient</th><th>se</th><th>zval</th><th>pval</th><th>significance</th></tr></thead><tbody>';
  DIRICHLET.forEach(d=>{html+=`<tr><td>${d.compartment}</td><td>${d.variable}</td><td>${d.coefficient}</td><td>${d.se}</td><td>${d.zval}</td><td>${d.pval}</td><td>${d.significance||''}</td></tr>`;});
  html+='</tbody>';
  const tbl=$('#dirichletTable').html(html);
  if($.fn.DataTable){if(tbl.hasClass('dataTable')) tbl.DataTable().destroy(); tbl.DataTable({paging:false,searching:false,info:false,dom:'Bfrtip',buttons:['csv']});}
}

function initComposition(){
  if(!COMPOSITION||!SAMPLE_KEY){$('#composition').html('<p>Composition data unavailable.</p>');return;}
  const sampleOpts=[...OBS_CATS];
  sampleOpts.forEach(c=>$('#compSampleKey').append(`<option value="${c}">${c}</option>`));
  $('#compSampleKey').val(SAMPLE_KEY);
  OBS_CATS.forEach(c=>$('#compGroupBy').append(`<option value="${c}">${c}</option>`));
  $('#compGroupBy').val(COMPOSITION.groupby);
  $('#compSampleKey, #compGroupBy, #compNorm, #compBarType').on('change',renderComposition);
  $('#compDownloadCounts').on('click',()=>downloadCompositionCSV('counts'));
  $('#compDownloadProps').on('click',()=>downloadCompositionCSV('props'));
  renderComposition();
  renderDirichlet();
}

let markersInit=false, topMarkersInit=false, enrichInit=false, tfInit=false, qcOverviewInit=false, qcPerClusterInit=false, compositionInit=false, volcanoInit=false, dgeInit=false, biologyInit=false;
const CONTEXT_BUDGET=20;
let currentTab=null,currentSub='';
let umapObsPurged=false,qcOverviewPurged=false,qcPerClusterPurged=false;
let lastMarkerGene=null,lastTopMarkerGene=null;

function purgePlotsIn(sel){
  const el=typeof sel==='string'?document.querySelector(sel):sel;
  if(!el) return 0;
  const plots=el.querySelectorAll('.js-plotly-plot');
  plots.forEach(gd=>Plotly.purge(gd));
  el.innerHTML='';
  return plots.length;
}

function baseGene(name){
  const idx = name.indexOf(' (');
  return idx>=0 ? name.slice(0, idx) : name;
}

function getExp(g){
  let arr = EXP_CACHE.get(g);
  if(arr) return arr;
  const e = EXP[g];
  if(e && e.i && e.x){
    arr = new Float32Array(NCELLS);
    const idx = GENE_INDEX[g];
    const vmin = VMIN[idx], vmax = VMAX[idx], rng = Math.max((vmax - vmin), 1e-6);
    for(let k=0;k<e.i.length;k++){
      arr[e.i[k]] = vmin + (e.x[k]/255)*rng;
    }
    EXP_CACHE.set(g, arr);
    if(EXP_CACHE.size > MAX_CACHE){
      const oldest = EXP_CACHE.keys().next().value;
      EXP_CACHE.delete(oldest);
    }
    return arr;
  }
  return new Float32Array(NCELLS);
}

function getProtExp(name){
  const idx = PROT_INDEX[name];
  if(idx===undefined) return new Float32Array(NCELLS);
  const e = PROT_EXP[name];
  if(!e) return new Float32Array(NCELLS);
  const out = new Float32Array(NCELLS);
  const vmin = PROT_VMIN[idx], vmax = PROT_VMAX[idx], rng = Math.max(vmax - vmin, 1e-6);
  for(let k=0;k<e.i.length;k++){ out[e.i[k]] = vmin + (e.x[k]/255)*rng; }
  return out;
}

function genePercentile(g, p){
  let gp = PERC_CACHE.get(g);
  if(!gp){gp={}; PERC_CACHE.set(g, gp);}
  if(gp[p] !== undefined) return gp[p];
  const arr = getExp(g);
  const val = percentile(arr, p);
  gp[p] = val;
  return val;
}
// NEW: helper to map expression value to quantile for threshold suggestions
function valueToQuantile(g, val){
  const arr = Array.from(getExp(g)).sort((a,b)=>a-b);
  let idx=0; while(idx<arr.length && arr[idx]<=val) idx++;
  return arr.length>1 ? idx/(arr.length-1) : 0.5;
}
function buildPlotlyScale(hexArray){
  const n = hexArray.length - 1;
  return hexArray.map((c,i)=>[i/n, c]);}

// Worker handling threshold suggestions
const coexprWorker = (()=>{
const src=`self.addEventListener('message',e=>{const d=e.data; if(d.type==='suggest'){const arr=new Float32Array(d.values); const o=otsu(arr); self.postMessage({type:'suggest',cut:o,gene:d.gene,target:d.target,method:'Otsu'});}});
function otsu(arr){const bins=256;let min=Infinity,max=-Infinity;for(const v of arr){if(isFinite(v)){if(v<min)min=v;if(v>max)max=v;}}const hist=new Array(bins).fill(0);const step=(max-min)/(bins-1)||1;for(const v of arr){if(isFinite(v)){const b=Math.min(bins-1,Math.floor((v-min)/step));hist[b]++;}}const total=arr.length;let sum=0;for(let i=0;i<bins;i++)sum+=i*hist[i];let wB=0,sumB=0,maxVar=-1,thr=0;for(let i=0;i<bins;i++){wB+=hist[i];if(!wB)continue;const wF=total-wB;if(!wF)break;sumB+=i*hist[i];const mB=sumB/wB,mF=(sum-sumB)/wF;const between=wB*wF*(mB-mF)*(mB-mF);if(between>maxVar){maxVar=between;thr=i;}}return min+thr*step;}
`;
return new Worker(URL.createObjectURL(new Blob([src],{type:'application/javascript'})));
})();

/**
 * Draw UMAP with low → mid → high layering so high expr lands on top.
 * container: DOM id or node
 * x, y: Float32Array | number[]
 * expr: number[] (expression for current gene)
 */

function drawScoreUMAP(container, arr, title){
  const scores = Array.from(arr);
  const hover = Array.from(CLUSTER_CODES, i => CLUSTER_NAMES[i]);
  let vmin = Math.min(...scores), vmax = Math.max(...scores);
  if(!isFinite(vmin) || !isFinite(vmax) || vmin === vmax){vmin = 0; vmax = 1;}
  // Paint order: low → high expression so bright cells land on top
  const order = scores.map((v,i)=>i).sort((a,b)=>scores[a]-scores[b]);
  const xs = order.map(i=>UMAP_X[i]);
  const ys = order.map(i=>UMAP_Y[i]);
  const sortedScores = order.map(i=>scores[i]);
  const sortedHover = order.map(i=>hover[i]);
  const trace = {x:xs, y:ys, mode:'markers', type:'scattergl', text:sortedHover,
                 hovertemplate: LEIDEN+': %{text}<extra></extra>',
                 marker:{size:5, color:sortedScores, cmin:vmin, cmax:vmax,
                         colorscale:buildPlotlyScale(CMAP), showscale:true,
                         colorbar:{...COLORBAR}}};
  const layout = {...PLOTLY_THEME.layout, title:{text:title, x:0.5}};
  return Plotly.newPlot(container, [trace], layout, PLOTLY_THEME.config);
}

let CURRENT_GENE_EXPR=null;
let CURRENT_PROT_EXPR=null;
  const SYNC_IDS=new Set();
  let syncingRanges=false;
  function wireSync(id){
    const gd=document.getElementById(id);
    if(!gd||typeof gd.on!=='function'||gd.dataset.wired) return;
    gd.dataset.wired=1;
    SYNC_IDS.add(id);
    gd.on('plotly_relayout',ev=>{
      if(!document.getElementById('linkRanges_'+DOM).checked) return;
      if(syncingRanges||ev['xaxis.range[0]']===undefined) return;
      syncingRanges=true;
      const xr=[ev['xaxis.range[0]'],ev['xaxis.range[1]']], yr=[ev['yaxis.range[0]'],ev['yaxis.range[1]']];
      SYNC_IDS.forEach(o=>{if(o!==id) Plotly.relayout(o,{'xaxis.range':xr,'yaxis.range':yr});});
      syncingRanges=false;
    });
  }
function setUMAPView(view){
  const cl=$('#clustCol_'+DOM), rn=$('#rnaCol_'+DOM), pr=$('#protCol_'+DOM);
  if(view==='RNA'){
    pr.addClass('d-none');
    cl.removeClass('col-lg-4').addClass('col-lg-6');
    rn.removeClass('d-none').removeClass('col-lg-4').addClass('col-lg-6');
  } else if(view==='PROT'){
    rn.addClass('d-none');
    pr.removeClass('d-none').removeClass('col-lg-4').addClass('col-lg-6');
    cl.removeClass('col-lg-4').addClass('col-lg-6');
  } else {
    rn.removeClass('d-none').removeClass('col-lg-6').addClass('col-lg-4');
    pr.removeClass('d-none').removeClass('col-lg-6').addClass('col-lg-4');
    cl.removeClass('col-lg-6').addClass('col-lg-4');
  }
  wireSync('clusterPlot_'+DOM);
  wireSync('genePlot_'+DOM);
  if(view!=='RNA') wireSync('protPlot_'+DOM);
}

let CLUSTER_META=null;
let lastCursor=null;

function clusterMeta(){
  if(CLUSTER_META) return CLUSTER_META;
  const meta=[];
  for(let ci=0;ci<CLUSTERS.length;ci++){
    const {xs,ys}=CLUSTER_PTS[ci];
    const count=xs.length;
    let mx=0,my=0;
    for(let k=0;k<count;k++){mx+=xs[k];my+=ys[k];}
    mx/=Math.max(count,1); my/=Math.max(count,1);
    let best=0,bestD=Infinity,radSum=0;
    for(let k=0;k<count;k++){
      const dx=xs[k]-mx, dy=ys[k]-my; const d=dx*dx+dy*dy; radSum+=d; if(d<bestD){bestD=d;best=k;}
    }
    const radius=Math.sqrt(radSum/Math.max(count,1));
    meta[ci]={xs,ys,count,medoid:{x:xs[best]||0,y:ys[best]||0},radius};
  }
  CLUSTER_META=meta;
  return meta;
}

function convexHull(xs, ys){
  const pts = xs.map((x,i)=>({x, y:ys[i]})).sort((a,b)=>a.x===b.x? a.y-b.y : a.x-b.x);
  if(pts.length<3) return pts;
  const cross=(o,a,b)=>(a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x);
  const lower=[];
  for(const p of pts){
    while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p)<=0) lower.pop();
    lower.push(p);
  }
  const upper=[];
  for(let i=pts.length-1;i>=0;i--){
    const p=pts[i];
    while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p)<=0) upper.pop();
    upper.push(p);
  }
  upper.pop();
  lower.pop();
  return lower.concat(upper);
}

function autoFont(n){
  return Math.max(9, Math.min(14, 14 - 0.08 * Math.max(n - 10, 0)));
}

function computeClusterAnnotations(gd, cursor){
  const xaxis=gd._fullLayout.xaxis;
  const yaxis=gd._fullLayout.yaxis;
  const meta=clusterMeta();
  lastCursor = cursor || lastCursor;
  const order = meta.map((m,ci)=>({ci,count:m.count})).sort((a,b)=>b.count-a.count);
  const ann=[], boxes= lastCursor?[lastCursor]:[], shapes=[];
  const fontSize = autoFont(CLUSTERS.length);
  const margin=6;
  const golden=2.39996322972865332;
  order.forEach(({ci})=>{
    const raw=CLUSTERS[ci];
    const m=meta[ci];
    const p0x=xaxis.l2p(m.medoid.x);
    const p0y=yaxis.l2p(m.medoid.y);
    const dirs=[[1,0],[Math.SQRT1_2,Math.SQRT1_2],[0,1],[-Math.SQRT1_2,Math.SQRT1_2],[-1,0],[-Math.SQRT1_2,-Math.SQRT1_2],[0,-1],[Math.SQRT1_2,-Math.SQRT1_2]];
    const bins=new Array(8).fill(0);
    for(let k=0;k<m.count;k++){
      const dx=m.xs[k]-m.medoid.x;
      const dy=m.ys[k]-m.medoid.y;
      const dist=Math.hypot(dx,dy);
      if(dist<m.radius){
        let ang=Math.atan2(dy,dx);
        let bin=Math.round(((ang+Math.PI)/(2*Math.PI))*8)%8;
        bins[bin]++;
      }
    }
    let dir=dirs[0], min=bins[0];
    for(let b=1;b<8;b++){if(bins[b]<min){min=bins[b];dir=dirs[b];}}
    let px=p0x+dir[0]*12;
    let py=p0y+dir[1]*12;
    const label=raw;
    const pad=3;
    let w=label.length*fontSize*0.6+pad*2;
    let h=fontSize*1.6+pad*2;
    const collide=(x,y)=>boxes.some(b=>!(x+w/2+margin<b.x-b.w/2-margin || x-w/2-margin>b.x+b.w/2+margin || y+h/2+margin<b.y-b.h/2-margin || y-h/2-margin>b.y+b.h/2+margin));
    let step=0;
    while(step<150 && collide(px,py)){
      const r=2*step; const ang=golden*step; px+=Math.cos(ang)*r; py+=Math.sin(ang)*r; step++;
    }
    if(collide(px,py)){
      w=label.length*fontSize*0.6+pad*2;
      h=fontSize*1.6+pad*2;
      step=0;
      while(step<150 && collide(px,py)){
        const r=2*step; const ang=golden*step; px+=Math.cos(ang)*r; py+=Math.sin(ang)*r; step++;
      }
    }
    boxes.push({x:px,y:py,w:w,h:h});
    const dx=xaxis.p2l(px);
    const dy=yaxis.p2l(py);
    const lbl={x:dx,y:dy,text:label,fontSize};
    ann.push(...buildHaloAnnotationsForLabel(lbl,{steps:10,radius:2,shadowColor:'rgba(255,255,255,0.9)'}));
    ann.push(buildMainAnnotation(lbl));
    if(Math.hypot(px-p0x,py-p0y)>8){
      shapes.push({type:'line',x0:m.medoid.x,y0:m.medoid.y,x1:dx,y1:dy,line:{color:'rgba(0,0,0,0.3)',width:1}});
    }
  });
  return {annotations:ann, shapes};
}

function buildHaloAnnotationsForLabel(lbl, opts){
  const {steps=8, radius=1.5, shadowColor='rgba(255,255,255,0.9)'} = opts || {};
  const halos=[];
  for(let k=0;k<steps;k++){
    const ang=(2*Math.PI*k)/steps;
    halos.push({
      x:lbl.x,y:lbl.y,xref:'x',yref:'y',
      text:lbl.text,showarrow:false,
      xshift:Math.round(Math.cos(ang)*radius),
      yshift:Math.round(Math.sin(ang)*radius),
      font:{size:lbl.fontSize,color:shadowColor,family:'Inter, system-ui, sans-serif'},
      align:'center'
    });
  }
  return halos;
}

function buildMainAnnotation(lbl){
  return {
    x:lbl.x,y:lbl.y,xref:'x',yref:'y',
    text:lbl.text,showarrow:false,
    font:{size:lbl.fontSize,color:'#000',family:'Inter, system-ui, sans-serif'},
    align:'center'
  };
}

function highlightCluster(gd, clusterName){
  const n=gd.data.length;
  const opacities=new Array(n).fill(0.15);
  const targets=[];
  for(let i=0;i<n;i++){
    const nm=gd.data[i].name;
    if(nm===clusterName) opacities[i]=1.0;
    targets.push(i);
  }
  Plotly.restyle(gd,{opacity:opacities},targets);
  const anns=gd.layout.annotations||[];
  const newAnns=anns.map(a=>{
    const plain=typeof a.text==='string'?a.text.replace(/<[^>]*>/g,'').replaceAll('\u00A0',' '):'';
    const base=plain.split(' (n=')[0];
    if(base===clusterName && a.font?.color?.startsWith('rgba(255,255,255')){
      return {...a,font:{...a.font,color:'rgba(255,255,255,1)'}};
    }
    if(base===clusterName){
      return {...a,font:{...a.font,color:'#000'}};
    }
    return a;
  });
  Plotly.relayout(gd,{annotations:newAnns});
}

function clearHighlight(gd){
  const n=gd.data.length;
  Plotly.restyle(gd,{opacity:1},[...Array(n).keys()]);
  const anns=gd.layout.annotations||[];
  const restored=anns.map(a=>{
    if(a.font?.color?.startsWith('rgba(255,255,255')){
      return {...a,font:{...a.font,color:'rgba(255,255,255,0.9)'}};
    }
    return a;
  });
  Plotly.relayout(gd,{annotations:restored});
}

function bindLegendHighlight(gd){
  const enter=ev=>{
    const clusterName=gd.data[ev.curveNumber].name;
    highlightCluster(gd,clusterName);
  };
  const leave=()=>{clearHighlight(gd);};
  gd.on('plotly_legendhover',enter);
  gd.on('plotly_legendunhover',leave);
  gd.on('plotly_legendmouseenter',enter);
  gd.on('plotly_legendmouseleave',leave);
  gd.on('plotly_legendclick',ev=>{enter(ev); return false;});
  gd.on('plotly_legenddoubleclick',ev=>{leave(); return false;});
  document.addEventListener('click',e=>{
    const legendEl=gd.querySelector('.legend');
    if(legendEl && !legendEl.contains(e.target)) leave();
  });
}

function drawUMAP(){
  const container = "clusterPlot_"+DOM;
  const BIG = 250000;
  const MED = 100000;
  const layout = {
    ...PLOTLY_THEME.layout,
    title:{text:'UMAP', x:0.5},
    showlegend:true,
    margin:{l:20,r:160,t:40,b:30},
    legend:{x:1.02,y:1,xanchor:'left',yanchor:'top',orientation:'v',bgcolor:'rgba(255,255,255,0)',borderwidth:0,itemclick:false,itemdoubleclick:false},
    dragmode:false,
    hovermode:false
  };
  const config = {staticPlot:false, displaylogo:false, responsive:true, scrollZoom:false, doubleClick:false};
  CLUSTER_META=null; lastCursor=null;
  if(NCELLS > BIG){
    let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
    for(let i=0;i<NCELLS;i++){
      const x=UMAP_X[i], y=UMAP_Y[i];
      if(x<xmin)xmin=x; if(x>xmax)xmax=x;
      if(y<ymin)ymin=y; if(y>ymax)ymax=y;
    }
    const canvas=document.createElement('canvas');
    canvas.width=800; canvas.height=800;
    const ctx=canvas.getContext('2d');
    ctx.globalAlpha=L_LEFT_POINT_OPACITY;
    const sx=(x)=>((x-xmin)/(xmax-xmin))*canvas.width;
    const sy=(y)=>canvas.height-((y-ymin)/(ymax-ymin))*canvas.height;
    for(let ci=0;ci<CLUSTERS.length;ci++){
      ctx.fillStyle=CLUSTER_COLORS[CLUSTERS[ci]];
      const {xs,ys}=CLUSTER_PTS[ci];
      for(let k=0;k<xs.length;k++){
        ctx.beginPath();
        ctx.arc(sx(xs[k]), sy(ys[k]), L_LEFT_POINT_SIZE/2, 0, Math.PI*2);
        ctx.fill();
      }
    }
    const url=canvas.toDataURL();
    layout.images=[{source:url,xref:'x',yref:'y',x:xmin,y:ymax,sizex:xmax-xmin,sizey:ymax-ymin,sizing:'stretch',layer:'below'}];
    const dummyTraces=CLUSTERS.map(c=>({x:[null],y:[null],type:'scatter',mode:'markers',name:c,legendgroup:c,marker:{size:L_LEFT_POINT_SIZE,opacity:0,color:CLUSTER_COLORS[c],line:{width:0}},hoverinfo:'skip'}));
    Plotly.newPlot(container, dummyTraces, layout, config).then(gd=>{
      const refresh=(cursor)=>{const res=computeClusterAnnotations(gd,cursor);Plotly.relayout(gd,{annotations:res.annotations, shapes:res.shapes});};
      refresh();
      gd.addEventListener('mousemove',e=>{const r=gd.getBoundingClientRect();refresh({x:e.clientX-r.left,y:e.clientY-r.top,w:1,h:1});});
      bindLegendHighlight(gd);
      wireSync(container);
    });
    return;
  }
  let traces;
  if(NCELLS > MED){
    const maxPts=50000;
    const perCl=Math.max(1,Math.floor(maxPts/CLUSTERS.length));
    traces=CLUSTERS.map((c,ci)=>{
      const pts=CLUSTER_PTS[ci];
      const xs=pts.xs.slice(0,perCl);
      const ys=pts.ys.slice(0,perCl);
      return {type:'scattergl',mode:'markers',x:xs,y:ys,name:""+c,legendgroup:c,marker:{size:L_LEFT_POINT_SIZE,opacity:L_LEFT_POINT_OPACITY,color:CLUSTER_COLORS[c],line:{width:0}},hoverinfo:'skip'};
    });
  } else {
    traces=CLUSTERS.map((c,ci)=>{
      const {xs,ys}=CLUSTER_PTS[ci];
      return {type:'scattergl',mode:'markers',x:xs,y:ys,name:""+c,legendgroup:c,marker:{size:L_LEFT_POINT_SIZE,opacity:L_LEFT_POINT_OPACITY,color:CLUSTER_COLORS[c],line:{width:0}},hoverinfo:'skip'};
    });
  }
  Plotly.newPlot(container, traces, layout, config).then(gd=>{
    const refresh=(cursor)=>{const res=computeClusterAnnotations(gd,cursor);Plotly.relayout(gd,{annotations:res.annotations, shapes:res.shapes});};
    refresh();
    gd.addEventListener('mousemove',e=>{const r=gd.getBoundingClientRect();refresh({x:e.clientX-r.left,y:e.clientY-r.top,w:1,h:1});});
    bindLegendHighlight(gd);
    wireSync(container);
  });
}

function drawBiologyUMAP(){
  const container = 'aiInsightsUMAP_'+DOM;
  const BIG = 250000;
  const MED = 100000;
  const layout = {
    ...PLOTLY_THEME.layout,
    title:{text:'UMAP', x:0.5},
    showlegend:true,
    margin:{l:20,r:160,t:40,b:30},
    legend:{x:1.02,y:1,xanchor:'left',yanchor:'top',orientation:'v',bgcolor:'rgba(255,255,255,0)',borderwidth:0,itemclick:false,itemdoubleclick:false},
    dragmode:false,
    hovermode:'closest'
  };
  const config = {staticPlot:false, displaylogo:false, responsive:true, scrollZoom:false, doubleClick:false};
  if(NCELLS > BIG){
    let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
    for(let i=0;i<NCELLS;i++){
      const x=UMAP_X[i], y=UMAP_Y[i];
      if(x<xmin)xmin=x; if(x>xmax)xmax=x;
      if(y<ymin)ymin=y; if(y>ymax)ymax=y;
    }
    const canvas=document.createElement('canvas');
    canvas.width=800; canvas.height=800;
    const ctx=canvas.getContext('2d');
    ctx.globalAlpha=L_LEFT_POINT_OPACITY;
    const sx=(x)=>((x-xmin)/(xmax-xmin))*canvas.width;
    const sy=(y)=>canvas.height-((y-ymin)/(ymax-ymin))*canvas.height;
    for(let ci=0;ci<CLUSTERS.length;ci++){
      ctx.fillStyle=CLUSTER_COLORS[CLUSTERS[ci]];
      const {xs,ys}=CLUSTER_PTS[ci];
      for(let k=0;k<xs.length;k++){
        ctx.beginPath();
        ctx.arc(sx(xs[k]), sy(ys[k]), L_LEFT_POINT_SIZE/2, 0, Math.PI*2);
        ctx.fill();
      }
    }
    const url=canvas.toDataURL();
    layout.images=[{source:url,xref:'x',yref:'y',x:xmin,y:ymax,sizex:xmax-xmin,sizey:ymax-ymin,sizing:'stretch',layer:'below'}];
    const dummyTraces=CLUSTERS.map(c=>({x:[null],y:[null],type:'scatter',mode:'markers',name:c,legendgroup:c,marker:{size:L_LEFT_POINT_SIZE,opacity:0,color:CLUSTER_COLORS[c],line:{width:0}},hoverinfo:'skip'}));
    Plotly.newPlot(container, dummyTraces, layout, config).then(gd=>{
      const refresh=(cursor)=>{const res=computeClusterAnnotations(gd,cursor);Plotly.relayout(gd,{annotations:res.annotations, shapes:res.shapes});};
      refresh();
      gd.addEventListener('mousemove',e=>{const r=gd.getBoundingClientRect();refresh({x:e.clientX-r.left,y:e.clientY-r.top,w:1,h:1});});
      bindLegendHighlight(gd);
      wireSync(container);
    });
    return;
  }
  let traces;
  if(NCELLS > MED){
    const maxPts=50000;
    const perCl=Math.max(1,Math.floor(maxPts/CLUSTERS.length));
    traces=CLUSTERS.map((c,ci)=>{
      const pts=CLUSTER_PTS[ci];
      const xs=pts.xs.slice(0,perCl);
      const ys=pts.ys.slice(0,perCl);
      const info = BIOLOGY_INFO[c] || {};
      return {
        type:'scattergl',mode:'markers',x:xs,y:ys,name:""+c,legendgroup:c,
        marker:{size:L_LEFT_POINT_SIZE,opacity:L_LEFT_POINT_OPACITY,color:CLUSTER_COLORS[c],line:{width:0}},
        meta:{
          canonical_label: info.canonical_label || 'N/A',
          fine_label: info.fine_label || 'N/A',
          confidence: info.confidence || 'N/A',
          key_markers: (info.key_markers||[]).join(', ')
        },
        hovertemplate:'Canonical Label: %{meta.canonical_label}<br>Fine Label: %{meta.fine_label}<br>Cell Confidence: %{meta.confidence}<br>Key Markers: %{meta.key_markers}<extra></extra>'
      };
    });
  } else {
    traces=CLUSTERS.map((c,ci)=>{
      const {xs,ys}=CLUSTER_PTS[ci];
      const info = BIOLOGY_INFO[c] || {};
      return {
        type:'scattergl',mode:'markers',x:xs,y:ys,name:""+c,legendgroup:c,
        marker:{size:L_LEFT_POINT_SIZE,opacity:L_LEFT_POINT_OPACITY,color:CLUSTER_COLORS[c],line:{width:0}},
        meta:{
          canonical_label: info.canonical_label || 'N/A',
          fine_label: info.fine_label || 'N/A',
          confidence: info.confidence || 'N/A',
          key_markers: (info.key_markers||[]).join(', ')
        },
        hovertemplate:'Canonical Label: %{meta.canonical_label}<br>Fine Label: %{meta.fine_label}<br>Cell Confidence: %{meta.confidence}<br>Key Markers: %{meta.key_markers}<extra></extra>'
      };
    });
  }
  Plotly.newPlot(container, traces, layout, config).then(gd=>{
    const refresh=(cursor)=>{const res=computeClusterAnnotations(gd,cursor);Plotly.relayout(gd,{annotations:res.annotations, shapes:res.shapes});};
    refresh();
    gd.addEventListener('mousemove',e=>{const r=gd.getBoundingClientRect();refresh({x:e.clientX-r.left,y:e.clientY-r.top,w:1,h:1});});
    bindLegendHighlight(gd);
    wireSync(container);
  });
}
function populateGenes(){
  const dl=document.getElementById("geneList_"+DOM);
  GENES.forEach(g=>{
    const o=document.createElement("option");
    o.value=g;
    dl.appendChild(o);
  });
}
function populateProteins(){
  const dl=document.getElementById("protList_"+DOM);
  PROT_GENES.forEach(p=>{ const o=document.createElement("option"); o.value=p; dl.appendChild(o); });
}
function drawGeneTo(id,g){
  const sym = baseGene(g);
  const expr = getExp(sym);
  CURRENT_GENE_EXPR = expr;
  drawScoreUMAP(id, expr, 'Gene expression: '+g).then(()=>{
    wireSync(id);
    wireSync('clusterPlot_'+DOM);
  });
}
function drawGene(g){
  drawGeneTo("genePlot_"+DOM,g);
}
function drawProteinTo(id,p){
  const arr = getProtExp(p);
  CURRENT_PROT_EXPR = arr;
  drawScoreUMAP(id, arr, "Protein expression: "+p).then(()=>{
    wireSync(id);
    wireSync('clusterPlot_'+DOM);
  });
}
  function drawProtein(p){
    drawProteinTo("genePlot_"+DOM,p);
  }

function setRandomUmapObsFeature(modality){
  const arr = modality==='Protein' ? PROT_GENES : GENES;
  const feat = arr.length ? arr[Math.floor(Math.random()*arr.length)] : '';
  $('#umapObsFeat_'+DOM).val(feat);
  umapObsGeneConfirmed = false;
}

  function populateObsGroupBy(){
    const sel = $("#obsGroupSel_"+DOM);
    sel.empty();
    OBS_CATS.forEach(c=>sel.append(`<option value="${c}">${c}</option>`));
    let preferred = OBS_CATS.find(c=>/group/i.test(c));
    if(!preferred) preferred = OBS_CATS.find(c=>/sample/i.test(c));
    if(!preferred && OBS_CATS.length) preferred = OBS_CATS[0];
    if(preferred) sel.val(preferred);
  }

  function drawUmapObs(){
    umapObsPurged=false;
    const groupby = $("#obsGroupSel_"+DOM).val();
    if(!groupby) return;
    const groupIdx = OBS_COL_MATRIX[groupby];
    const levels = OBS_LEVELS[groupby] || [];
    const colorsMap = OBS_COLORS[groupby] || {};
    const modality = HAS_PROT ? $("#umapObsMod_"+DOM).val() : 'RNA';
    let feature = $("#umapObsFeat_"+DOM).val().trim();
    if(modality==='RNA') feature = baseGene(feature);
    let expr=null, vmin=0, vmax=1, idx;
    if(feature){
      if(modality==='RNA'){
        idx = GENE_INDEX[feature];
        if(idx!==undefined){ expr = getExp(feature); vmin = VMIN[idx]; vmax = VMAX[idx]; }
      } else {
        idx = PROT_INDEX[feature];
        if(idx!==undefined){ expr = getProtExp(feature); vmin = PROT_VMIN[idx]; vmax = PROT_VMAX[idx]; }
      }
    }
    const colorByExpr = umapObsGeneConfirmed && expr && idx!==undefined;
    const scale = buildPlotlyScale(CMAP);
    $('#umapObsTitle_'+DOM).text(colorByExpr ? feature : '');
    const view = $('input[name="umapObsView_'+DOM+'"]:checked').val() || 'umap';
    if(view==='violin'){
      $('#umapObsGrid_'+DOM).hide();
      $('#umapObsViolin_'+DOM).show();
        if(!colorByExpr){ Plotly.purge('umapObsViolin_'+DOM); return; }
          const scores = Array.from(expr, v => v + PSEUDOCOUNT);
          const traces = levels.map((level,i)=>{
            const yvals = scores.filter((_,j)=>groupIdx && groupIdx[j]===i);
            const n = yvals.length;
            return {
              type:'violin',
              y:yvals,
              name:`${level} (n=${n})`,
              points:'all',
              jitter:0.3,
              pointpos:0,
              marker:{
                color:colorsMap[level]||`hsl(${(360*i)/Math.max(levels.length,1)},65%,50%)`,
                size:2,
                opacity:0.3
              },
              hovertemplate:`${groupby}: ${level}<br>n: ${n}<extra></extra>`,
              box:{visible:false}
            };
          });
        const vioLayout = createViolinLayout('Distribution of '+feature+' across '+groupby, levels);
        vioLayout.yaxis = {...vioLayout.yaxis, title:'Expression', type:'linear'};
        Plotly.newPlot('umapObsViolin_'+DOM,traces,vioLayout,PLOTLY_THEME.config)
          .then(gd=>requestAnimationFrame(()=>Plotly.Plots.resize(gd)));
        return;
    }
    $('#umapObsViolin_'+DOM).hide();
    const grid = $("#umapObsGrid_"+DOM).empty().show();
    const [rows, cols] = (function(n){
      if(n<=1) return [1,1];
      if(n===2) return [1,2];
      if(n===3) return [1,3];
      if(n===4) return [2,2];
      if(n<=6) return [2,3];
      if(n<=9) return [3,3];
      if(n<=12) return [3,4];
      if(n<=16) return [4,4];
      const c = Math.ceil(Math.sqrt(n));
      const r = Math.ceil(n/c);
      return [r,c];
    })(levels.length);
    grid.css({
      'grid-template-columns': `repeat(${cols}, 1fr)`,
      'grid-template-rows': `repeat(${rows}, 1fr)`
    });
    const showBackground = $('#obsShowBackground_'+DOM).prop('checked');
    for(let i=0;i<levels.length;i++){
      const level = levels[i];
      const div = document.createElement('div');
      div.id = `umapObsFacet_${DOM}_${i}`;
      const plotDiv = document.createElement('div');
      plotDiv.style.width = '100%';
      plotDiv.style.height = '100%';
      div.appendChild(plotDiv);
      grid.append(div);
      let xs=[], ys=[], h=[], vals=[];
      for(let j=0;j<NCELLS;j++){
        if(groupIdx && groupIdx[j]===i){
          xs.push(UMAP_X[j]);
          ys.push(UMAP_Y[j]);
          if(colorByExpr){
            vals.push(expr[j]);
            h.push(`${CELLS[j]}<br>${feature}:${expr[j].toFixed(2)}`);
          } else {
            h.push(CELLS[j]);
          }
        }
      }
      if(colorByExpr){
        const order = vals.map((v,k)=>k).sort((a,b)=>vals[a]-vals[b]);
        xs = order.map(k=>xs[k]);
        ys = order.map(k=>ys[k]);
        vals = order.map(k=>vals[k]);
        h = order.map(k=>h[k]);
      }
      const traces=[];
      if(showBackground){
        traces.push({x:UMAP_X,y:UMAP_Y,mode:'markers',type:'scattergl',marker:{color:'rgba(200,200,200,0.35)',size:3},hoverinfo:'skip'});
      }
      const marker = colorByExpr
        ? {size:5,color:vals,cmin:vmin,cmax:vmax,colorscale:scale,showscale:true,
           colorbar:{...COLORBAR,orientation:'v',x:1.05,xanchor:'left',y:0.5,yanchor:'middle',title:feature}}
        : {size:5,color:colorsMap[level]||`hsl(${(360*i)/Math.max(levels.length,1)},65%,50%)`};
      traces.push({x:xs,y:ys,text:h,hovertemplate:'%{text}<extra></extra>',mode:'markers',type:'scattergl',marker});
      const layout={
        ...PLOTLY_THEME.layout,
        title:{text:level,x:0.5},
        xaxis:{visible:false,range:UMAP_XRANGE},
        yaxis:{visible:false,range:UMAP_YRANGE,scaleanchor:'x'},
        margin:{l:20,r:50,t:30,b:20}
      };
      Plotly.newPlot(plotDiv,traces,layout,PLOTLY_THEME.config)
        .then(gd=>requestAnimationFrame(()=>Plotly.Plots.resize(gd)));
    }
  }
function drawMarkerGene(g){
  lastMarkerGene=g;
  if(HAS_PROT && CURRENT_MODALITY==='Protein'){
    drawProteinTo("markerUMAP_"+DOM,g);
  } else {
    drawGeneTo("markerUMAP_"+DOM,g);
  }
}
function populateMarkerSelectors(){
  const mSel=document.getElementById("methodSel_"+DOM);
  const cSel=document.getElementById("clusterSel_"+DOM);
  if(HAS_PROT){
    cSel.innerHTML='';
    const frag=document.createDocumentFragment();
    const clusters=Object.keys(MARKERS[CURRENT_MODALITY]||{});
    clusters.forEach(c=>{
      const opt=document.createElement('option');
      opt.value=c; opt.textContent=c;
      frag.appendChild(opt);
    });
    cSel.appendChild(frag);
    const saved=markerClusterByMod[CURRENT_MODALITY];
    if(saved && clusters.includes(saved)){
      cSel.value=saved;
    }else if(clusters.length){
      cSel.value=clusters[0];
    }
    markerClusterByMod[CURRENT_MODALITY]=cSel.value;
    updateMarkerTable();
  } else {
    mSel.innerHTML='';
    const frag=document.createDocumentFragment();
    Object.keys(MARKERS).forEach(m=>{
      const opt=document.createElement('option');
      opt.value=m; opt.textContent=m;
      frag.appendChild(opt);
    });
    mSel.appendChild(frag);
    updateMarkerClusters();
  }
}
function updateMarkerClusters(){
  if(HAS_PROT){
    populateMarkerSelectors();
    return;
  }
  const method=document.getElementById("methodSel_"+DOM).value;
  const cSel=document.getElementById("clusterSel_"+DOM);
  cSel.innerHTML='';
  const frag=document.createDocumentFragment();
  Object.keys(MARKERS[method]).forEach(c=>{
    const opt=document.createElement('option');
    opt.value=c; opt.textContent=c;
    frag.appendChild(opt);
  });
  cSel.appendChild(frag);
  updateMarkerTable();
}
function enablePlainSort(table){
  const ths = table.querySelectorAll('th');
  ths.forEach((th, idx) => {
    th.style.cursor = 'pointer';
    th.addEventListener('click', () => {
      const tbody = table.tBodies[0];
      const rows = Array.from(tbody.querySelectorAll('tr'));
      const dir = th.dataset.dir === 'asc' ? 'desc' : 'asc';
      th.dataset.dir = dir;
      rows.sort((a, b) => {
        const av = a.children[idx].getAttribute('data-order') || a.children[idx].textContent;
        const bv = b.children[idx].getAttribute('data-order') || b.children[idx].textContent;
        const diff = parseFloat(av) - parseFloat(bv);
        return dir === 'asc' ? diff : -diff;
      });
      rows.forEach(r => tbody.appendChild(r));
    });
  });
}
function updateMarkerTable(){
  let rows=[], label='Gene', fname='markers';
  if(HAS_PROT){
    const cluster=document.getElementById("clusterSel_"+DOM).value;
    rows=[...(MARKERS[CURRENT_MODALITY][cluster]||[])];
    label = CURRENT_MODALITY==='Protein'?'Protein':'Gene';
    fname += '_'+CURRENT_MODALITY.toLowerCase();
  } else {
    const method=document.getElementById("methodSel_"+DOM).value;
    const cluster=document.getElementById("clusterSel_"+DOM).value;
    rows=[...(MARKERS[method][cluster]||[])];
  }
  rows.sort((a,b)=>(b.scores??0)-(a.scores??0));
  const tblEl=document.getElementById("markerTable_"+DOM);
  const tbl=$(tblEl);
  if($.fn.DataTable && tbl.hasClass('dataTable')) tbl.DataTable().destroy();
  tblEl.innerHTML=`<thead><tr><th>${label}</th><th>Score</th><th>logFC</th><th>Adj.P</th></tr></thead><tbody></tbody>`;
  const tbody=tblEl.querySelector('tbody');
  const frag=document.createDocumentFragment();
  rows.forEach(r=>{
    const pv = r.pvals_adj!==undefined ? r.pvals_adj : r.pvals;
    const pvStr = (pv!==undefined && !isNaN(pv)) ? Number(pv).toExponential(2) : '';
    const tr=document.createElement('tr');
    tr.innerHTML =
      `<td>${r.names}</td>`+
      `<td data-order="${r.scores}">${Number(r.scores).toFixed(2)}</td>`+
      `<td data-order="${r.logfoldchanges}">${Number(r.logfoldchanges).toFixed(2)}</td>`+
      `<td data-order="${pv}">${pvStr}</td>`;
    frag.appendChild(tr);
  });
  tbody.appendChild(frag);
  if($.fn.DataTable){
    const opts={
      paging:false,
      searching:true,
      info:false,
      ordering:true,
      order:[[1,'desc']],
      columnDefs:[{targets:[1,2,3],type:'num'}]
    };
    if($.fn.DataTable.Buttons){
      opts.dom='Bfrtip';
      opts.buttons=[{extend:'csv',filename:fname,text:'Download CSV'}];
    }
    tbl.on('init.dt', function(){
      $(this).closest('.dataTables_wrapper').css({'max-height':'calc(100vh - 300px)','overflow':'auto'}).find('.dt-buttons').addClass('float-end mb-2');
    });
    tbl.DataTable({...opts, fixedHeader:true, autoWidth:false});
  } else {
    enablePlainSort(tblEl);
  }
  if(rows.length){const r=rows[Math.floor(Math.random()*rows.length)].names;drawMarkerGene(r);}
}
function drawTopMarkerGene(g){
  lastTopMarkerGene=g;
  if(HAS_PROT && CURRENT_MODALITY==='Protein'){
    drawProteinTo("topMarkerUMAP_"+DOM,g);
  } else {
    drawGeneTo("topMarkerUMAP_"+DOM,g);
  }
}
function populateTopMarkerClusters(){
  const cSel=$("#topClusterSel_"+DOM); cSel.empty();
  if(HAS_PROT){
    const clusters=Object.keys(TOP_MARKERS[CURRENT_MODALITY]||{});
    clusters.forEach(c=>cSel.append(`<option value="${c}">${c}</option>`));
    const saved=topMarkerClusterByMod[CURRENT_MODALITY];
    if(saved && clusters.includes(saved)){
      cSel.val(saved);
    }else if(clusters.length){
      cSel.val(clusters[0]);
    }
    topMarkerClusterByMod[CURRENT_MODALITY]=cSel.val();
  } else {
    Object.keys(TOP_MARKERS).forEach(c=>cSel.append(`<option value="${c}">${c}</option>`));
  }
  updateTopMarkerTable();
}
function updateTopMarkerTable(){
  let rows=[], label='Gene', fname='top_markers';
  if(HAS_PROT){
    const cluster=$("#topClusterSel_"+DOM).val();
    rows=[...(TOP_MARKERS[CURRENT_MODALITY][cluster]||[])];
    label = CURRENT_MODALITY==='Protein'?'Protein':'Gene';
    fname += '_'+CURRENT_MODALITY.toLowerCase();
  } else {
    const cluster=$("#topClusterSel_"+DOM).val();
    rows=[...(TOP_MARKERS[cluster]||[])];
  }
  rows.sort((a,b)=>(b.scores??0)-(a.scores??0));
  const tbl=$("#topMarkerTable_"+DOM);
  if($.fn.DataTable && tbl.hasClass('dataTable')) tbl.DataTable().destroy();
  const hasScore=rows.length && rows[0].scores!==undefined;
  const hasFC=rows.length && rows[0].logfoldchanges!==undefined;
  const hasP=rows.length && (rows[0].pvals_adj!==undefined||rows[0].pvals!==undefined);
  let html=`<thead><tr><th>${label}</th>`;
  if(hasScore) html+='<th>Score</th>';
  if(hasFC) html+='<th>logFC</th>';
  if(hasP) html+='<th>Adj.P</th>';
  html+='</tr></thead><tbody>';
  rows.forEach(r=>{
    html+=`<tr><td>${r.names}</td>`;
    if(hasScore) html+=`<td data-order="${r.scores}">${Number(r.scores).toFixed(2)}</td>`;
    if(hasFC) html+=`<td data-order="${r.logfoldchanges}">${Number(r.logfoldchanges).toFixed(2)}</td>`;
    if(hasP){
      const pv=r.pvals_adj!==undefined?r.pvals_adj:r.pvals;
      const pvStr=(pv!==undefined&&!isNaN(pv))?Number(pv).toExponential(2):'';
      html+=`<td data-order="${pv}">${pvStr}</td>`;
    }
    html+='</tr>';
  });
  html+='</tbody>'; tbl.html(html);
    if($.fn.DataTable){
      const opts={
        paging:false,
        searching:true,
        info:false,
        ordering:true
      };
      if($.fn.DataTable.Buttons){
        opts.dom='Bfrtip';
        opts.buttons=[{extend:'csv',filename:fname,text:'Download CSV'}];
      }
      const numTargets=[];
      let orderIdx=0;
      let col=1;
      if(hasScore){numTargets.push(col); orderIdx=col; col++;}
      if(hasFC){numTargets.push(col); if(!hasScore) orderIdx=col; col++;}
      if(hasP){numTargets.push(col); col++;}
      opts.order=[[orderIdx,'desc']];
      opts.columnDefs=[{targets:numTargets,type:'num'}];
      tbl.on('init.dt', function(){
        $(this).closest('.dataTables_wrapper').css({'max-height':'calc(100vh - 300px)','overflow':'auto'}).find('.dt-buttons').addClass('float-end mb-2');
      });
      tbl.DataTable({...opts, fixedHeader:true, autoWidth:false});
    } else {
      enablePlainSort(tbl[0]);
    }
  $("#topMarkerTable_"+DOM+" tbody tr").on("click",function(){const g=$(this).find('td').first().text();$("#geneInput_"+DOM).val(g);drawTopMarkerGene(g);});
  if(rows.length){const r=rows[Math.floor(Math.random()*rows.length)].names;drawTopMarkerGene(r);}
}

function populateEnrichClusters(){
  const cSel=$("#enrichClusterSel_"+DOM); cSel.empty();
  Object.keys(CTYPES).forEach(c=>cSel.append(`<option value="${c}">${c}</option>`));
  updateEnrichTypes();
}
function updateEnrichTypes(){
  const cluster=$("#enrichClusterSel_"+DOM).val();
  const types=CTYPES[cluster]||[];
  const tSel=$("#enrichTypeSel_"+DOM); tSel.empty();
  types.forEach(t=>tSel.append(`<option value="${t}">${t}</option>`));
  if(types.length) tSel.val(types[0]);
  drawEnrich();
}
function createViolinLayout(title, groups=CLUSTERS){
  const maxLabelLen = Math.max(0, ...groups.map(c=>c.length));
  const n = groups.length;
  const angle = (n>15 || maxLabelLen>10) ? -45 : 0;
  const fontSize = n>20 ? 8 : 10;
  const bottom = Math.max(80, fontSize*4 + maxLabelLen*7);
  return {
    ...PLOTLY_THEME.layout,
    title:{text:title, x:0.5},
    font:{family:'Helvetica', size:14},
    paper_bgcolor:'#ffffff',
    plot_bgcolor:'#ffffff',
    yaxis:{
      title:'Score',
      showline:true,
      mirror:true,
      ticks:'outside',
      tickwidth:1,
      tickcolor:'#000'
    },
    xaxis:{
      automargin:true,
      tickangle:angle,
      tickfont:{size:fontSize},
      showline:true,
      mirror:true,
      ticks:'outside',
      tickwidth:1,
      tickcolor:'#000'
    },
    margin:{l:60,r:20,t:50,b:bottom},
    showlegend:false
  };
}
function drawEnrich(){
  const ctype=$("#enrichTypeSel_"+DOM).val();
  if(!ctype) return;
    const raw=getEnrichFloat(ctype);
    const scores=Array.from(raw, v => v + PSEUDOCOUNT);
  const hover = Array.from(CLUSTER_CODES, i => CLUSTER_NAMES[i]);
  drawScoreUMAP('enrichUMAP_'+DOM, raw, 'Predicted annotation score: '+ctype);
    const vioTraces=CLUSTERS.map(c=>({
      type:'violin',
      y:scores.filter((_,i)=>hover[i]==c),
      name:c,
      points:'all',
      pointpos:0,
      marker:{color:CLUSTER_COLORS[c]},
      hovertemplate:LEIDEN+': '+c+'<extra></extra>',
      box:{visible:true}
    }));
  const vioLayout=createViolinLayout('Distribution of '+ctype+' scores across '+LEIDEN);
  try{
    Plotly.newPlot('enrichViolin_'+DOM,vioTraces,vioLayout,PLOTLY_THEME.config);
  }catch(e){
    console.error('Failed to render enrichment violin plot',e);
  }
}


function percentile(arr, p){
  const a=Array.from(arr).sort((x,y)=>x-y);
  const idx=Math.min(a.length-1, Math.max(0, Math.floor(p*(a.length-1))));
  return a[idx];
}

function updateLegend(mode, gA, gB){
  const leg=$("#coexprLegend_"+DOM);
  if(mode==='bivariate'){
    leg.html('<div class="d-flex gap-2 flex-wrap align-items-center">'+
      `<span class="badge rounded-pill text-bg-light border"><span class="rounded-pill me-1" style="display:inline-block;width:12px;height:12px;background:#ff00ff"></span>${gA} & ${gB} high</span>`+
      `<span class="badge rounded-pill text-bg-light border"><span class="rounded-pill me-1" style="display:inline-block;width:12px;height:12px;background:#ff0000"></span>${gA} high</span>`+
      `<span class="badge rounded-pill text-bg-light border"><span class="rounded-pill me-1" style="display:inline-block;width:12px;height:12px;background:#0000ff"></span>${gB} high</span>`+
      `<span class="badge rounded-pill text-bg-light border"><span class="rounded-pill me-1" style="display:inline-block;width:12px;height:12px;background:#bdbdbd"></span>low</span>`+
    '</div>');
  } else {
    leg.html(
      `<div class="mb-1" style="width:120px;height:15px;background:linear-gradient(to right, #0000ff, #ffffff, #ff0000);"></div>`+
      `<div class="d-flex justify-content-between" style="width:120px"><small>${gB}</small><small>equal</small><small>${gA}</small></div>`
    );
  }
}


// NEW: handle threshold suggestion results
function handleSuggest(d){
  const q=valueToQuantile(d.gene,d.cut);
  if(d.target==='A'){
    $('#quantileA_'+DOM).val(q);
    $('#suggestCaptionA_'+DOM).text(`Suggested by ${d.method} (cut=${d.cut.toFixed(2)})`);
  } else {
    $('#quantileB_'+DOM).val(q);
    $('#suggestCaptionB_'+DOM).text(`Suggested by ${d.method} (cut=${d.cut.toFixed(2)})`);
  }
  drawCoexpr();
}

coexprWorker.onmessage=e=>{
  const d=e.data;
  if(d.type==='suggest') handleSuggest(d);
};

function suggestCut(target){
  const gene=baseGene($('#gene'+target+'Input_'+DOM).val());
  const arr=getExp(gene).slice(0);
  coexprWorker.postMessage({type:'suggest',values:arr.buffer,gene:gene,target:target},[arr.buffer]);
}

// NEW: signature scoring worker
const sigWorker = (()=>{
  const src=`self.addEventListener('message',e=>{const d=e.data;const genes=d.genes;const n=d.n;const out=new Float32Array(n);for(let gi=0;gi<genes;gi++){const g=new Float32Array(d.expr[gi]);let mean=0,M2=0;for(let i=0;i<n;i++){const x=g[i];const delta=x-mean;mean+=delta/(i+1);M2+=delta*(x-mean);}const sd=Math.sqrt(M2/(n-1)||1);for(let i=0;i<n;i++){out[i]+=sd?((g[i]-mean)/sd):0;}}for(let i=0;i<n;i++)out[i]/=genes;self.postMessage({scores:out.buffer},[out.buffer]);});`;
  return new Worker(URL.createObjectURL(new Blob([src],{type:'application/javascript'})));
})();

function scoreSignature(){
  const genes=$('#sigGenes_'+DOM).val().split(/\s+/).map(g=>baseGene(g.trim())).filter(g=>g&&EXP[g]);
  if(!genes.length){$('#sigInfo_'+DOM).text('No valid genes');return;}
  const arrays=genes.map(g=>getExp(g).slice(0));
  const buffers=arrays.map(a=>a.buffer);
  sigWorker.onmessage=e=>{
    const scores=new Float32Array(e.data.scores);
    drawScoreUMAP('sigUMAP_'+DOM,scores,'Signature score');
    $('#sigInfo_'+DOM).text(`Scored ${genes.length} genes`);
    registerVirtualGene('Sig 1',scores);
  };
  sigWorker.postMessage({genes:genes.length,expr:buffers,n:NCELLS},buffers);
}

function registerVirtualGene(name, values){
  EXP['sig:'+name]=values;
  if(!GENES.includes('sig:'+name)) {GENES.push('sig:'+name); populateGenes();}
}

function drawCoexpr(){
  const gA=baseGene($("#geneAInput_"+DOM).val());
  const gB=baseGene($("#geneBInput_"+DOM).val());
  if(!EXP[gA]||!EXP[gB]) return;
  const hover = Array.from(CLUSTER_CODES, i => CLUSTER_NAMES[i]);
  let a=getExp(gA).slice(0);
  let b=getExp(gB).slice(0);
  const mode=$("#modeSel_"+DOM).val();
  const transform=$("#transformSel_"+DOM).val();
  const clipHi=Number($("#clip_"+DOM).val());
  const binOn=$("#binarize_"+DOM).prop('checked');
  const binQ=Number($("#binarizeQ_"+DOM).val());
  const qA=Number($("#quantileA_"+DOM).val());
  const qB=Number($("#quantileB_"+DOM).val());
  const loAraw=genePercentile(gA,0.02), hiAraw=genePercentile(gA,clipHi/100);
  const loBraw=genePercentile(gB,0.02), hiBraw=genePercentile(gB,clipHi/100);
  if(transform==='log1p'){for(let i=0;i<NCELLS;i++){a[i]=Math.log1p(a[i]);b[i]=Math.log1p(b[i]);}}
  const loA=transform==='log1p'?Math.log1p(loAraw):loAraw;
  const hiA=transform==='log1p'?Math.log1p(hiAraw):hiAraw;
  const loB=transform==='log1p'?Math.log1p(loBraw):loBraw;
  const hiB=transform==='log1p'?Math.log1p(hiBraw):hiBraw;
  let minA=loA,maxA=hiA,minB=loB,maxB=hiB;
  if($("#globalScale_"+DOM).prop('checked')){
    const gmin=Math.min(minA,minB);
    const gmax=Math.max(maxA,maxB);
    minA=minB=gmin; maxA=maxB=gmax;
  }
  for(let i=0;i<NCELLS;i++){
    a[i]=Math.min(maxA, Math.max(minA,a[i]));
    b[i]=Math.min(maxB, Math.max(minB,b[i]));
  }
  if(binOn){
    const thAraw=genePercentile(gA,binQ), thBraw=genePercentile(gB,binQ);
    const thA=transform==='log1p'?Math.log1p(thAraw):thAraw;
    const thB=transform==='log1p'?Math.log1p(thBraw):thBraw;
    for(let i=0;i<NCELLS;i++){a[i]=a[i]>thA?1:0; b[i]=b[i]>thB?1:0;}
  } else {
    for(let i=0;i<NCELLS;i++){a[i]=(a[i]-minA)/Math.max(maxA-minA,1e-6); b[i]=(b[i]-minB)/Math.max(maxB-minB,1e-6);}
  }
  let idx=Array.from({length:NCELLS},(_,i)=>i);
  let colors=new Array(NCELLS);
  if(mode==='bivariate'){
    const qAraw=genePercentile(gA,qA), qBraw=genePercentile(gB,qB);
    const thA=transform==='log1p'?Math.log1p(qAraw):qAraw;
    const thB=transform==='log1p'?Math.log1p(qBraw):qBraw;
    idx.sort((i,j)=>(a[i]+b[i])-(a[j]+b[j]));
    for(let i=0;i<NCELLS;i++){
      const hiA=a[i]>thA, hiB=b[i]>thB;
      let c='#bdbdbd';
      if(hiA&&hiB) c='#ff00ff';
      else if(hiA) c='#ff0000';
      else if(hiB) c='#0000ff';
      colors[i]=c;
    }
    $("#ratioTable_"+DOM).empty();
  } else {
    const ratio=new Float32Array(NCELLS);
    for(let i=0;i<NCELLS;i++){
      let r=a[i]/(b[i]+1e-9);
      if(transform==='logratio') r=Math.log2((a[i]+1e-9)/(b[i]+1e-9));
      ratio[i]=r;
    }
    idx.sort((i,j)=>Math.abs(Math.log2((a[i]+1e-9)/(b[i]+1e-9)))-Math.abs(Math.log2((a[j]+1e-9)/(b[j]+1e-9))));
    const maxAbs=Math.max(...Array.from(ratio, v=>Math.abs(v)))||1;
    for(let i=0;i<NCELLS;i++){
      const t=(ratio[i]+maxAbs)/(2*maxAbs);
      const R=Math.round(255*t);
      const B=Math.round(255*(1-t));
      colors[i]=`rgb(${R},0,${B})`;
    }
    // mini table for extreme ratios
    const tbl=$("#ratioTable_"+DOM);
    const top=idx.slice(-10).reverse();
    let html='<thead><tr><th>Cell</th><th>Cluster</th><th>log2(A/B)</th></tr></thead><tbody>';
    top.forEach(i=>{const lr=Math.log2((a[i]+1e-9)/(b[i]+1e-9)); html+=`<tr><td>${CELLS[i]}</td><td>${CLUSTER_NAMES[CLUSTER_CODES[i]]}</td><td>${lr.toFixed(2)}</td></tr>`;});
    html+='</tbody>'; tbl.html(html);
    if($.fn.DataTable){
      if(tbl.hasClass('dataTable')) tbl.DataTable().destroy();
      tbl.on('init.dt', function(){
        $(this).closest('.dataTables_wrapper').find('.dt-buttons').addClass('float-end mb-2');
      });
      tbl.DataTable({paging:false,searching:false,info:false,fixedHeader:true,autoWidth:false});
    }
  }
    const x=idx.map(i=>UMAP_X[i]);
    const y=idx.map(i=>UMAP_Y[i]);
    const h=idx.map(i=>hover[i]);
    const c=idx.map(i=>colors[i]);
    const trace={x:x,y:y,text:h,hovertemplate:LEIDEN+': %{text}<extra></extra>',mode:'markers',type:'scattergl',marker:{color:c,size:5,opacity:0.7}};
    Plotly.newPlot('coexprPlot_'+DOM,[trace],{...PLOTLY_THEME.layout, hovermode:'closest'},PLOTLY_THEME.config);
    updateLegend(mode, gA, gB);
}

function initTF(){
  const sel=document.getElementById('tfCelltype');
  TF_CELLTYPES.forEach(ct=>{
    const opt=document.createElement('option'); opt.value=ct; opt.textContent=ct; sel.appendChild(opt);
  });
  sel.addEventListener('change', renderTF);
}

function renderTF(){
  const ct=document.getElementById('tfCelltype').value;
  const b64=TF_BARPLOTS[ct];
  const div=document.getElementById('tfBarplot');
  if(b64){
    div.innerHTML = `<img src="data:image/png;base64,${b64}" class="img-fluid"/>`;
  } else {
    div.innerHTML = '';
  }
}

function initVolcano(){
  const sel=document.getElementById('volcanoCelltype');
  VOLCANO_CELLTYPES.forEach(ct=>{
    const opt=document.createElement('option'); opt.value=ct; opt.textContent=ct; sel.appendChild(opt);
  });
  sel.addEventListener('change', renderVolcano);
}

async function renderVolcano(){
  const ct=document.getElementById('volcanoCelltype').value;
  const res = VOLCANO_DATA[ct];      // injected via code_pseudo.txt
  const baseLayout={
    ...PLOTLY_THEME.layout,
    paper_bgcolor:'#ffffff',
    plot_bgcolor:'#ffffff',
    margin:{l:60,r:20,t:50,b:60},
    xaxis:{showline:true,mirror:true,ticks:'outside',tickwidth:1,tickcolor:'#000',automargin:true},
    yaxis:{showline:true,mirror:true,ticks:'outside',tickwidth:1,tickcolor:'#000',automargin:true}
  };
  Plotly.react('volcanoPlot', res.volcanoTraces,
    {...baseLayout, xaxis:{...baseLayout.xaxis, title:'log2FC'}, yaxis:{...baseLayout.yaxis, title:'-log10(FDR)'}, hovermode:'closest'},
    PLOTLY_THEME.config);
  const plot=document.getElementById('volcanoPlot');
  plot.removeAllListeners && plot.removeAllListeners('plotly_click');
  function updateBox(gene){
    const traces = res.boxData[gene] || [];
    Plotly.react('volcanoBox', traces,
      {...baseLayout, xaxis:{...baseLayout.xaxis, title:res.groupLabel}, yaxis:{...baseLayout.yaxis, title:'log1p counts'}, title:gene},
      PLOTLY_THEME.config);
  }
  updateBox(res.defaultGene);
  plot.on('plotly_click', ev => { updateBox(ev.points[0].customdata); });
}

function initDGE(){
  const sel=document.getElementById('dgeCelltype');
  DGE_CELLTYPES.forEach(ct=>{
    const opt=document.createElement('option'); opt.value=ct; opt.textContent=ct; sel.appendChild(opt);
  });
  sel.addEventListener('change', renderDGE);
}

function renderDGE(){
  const ct=document.getElementById('dgeCelltype').value;
  const res=DGE_DATA[ct];
  const tbl=$('#dgeTable');
  const fmt=x=>Number.parseFloat(x).toPrecision(3);
  res.table.sort((a,b)=>Math.abs(b.LR)-Math.abs(a.LR));
  let html='<thead><tr><th>Gene</th><th>log2FoldChange</th><th>abs(LR)</th><th>FDR</th></tr></thead><tbody>';
  res.table.forEach(r=>{
    const lr=Math.abs(r.LR);
    html+=`<tr data-gene="${r.gene_symbol}"><td>${r.gene_symbol}</td><td data-order="${r.log2FoldChange}">${fmt(r.log2FoldChange)}</td><td data-order="${lr}">${fmt(lr)}</td><td data-order="${r.FDR}">${fmt(r.FDR)}</td></tr>`;
  });
  html+='</tbody>';
  tbl.html(html);
  if($.fn.DataTable){
    if(tbl.hasClass('dataTable')) tbl.DataTable().destroy();
    tbl.on('init.dt', function(){
      $(this).closest('.dataTables_wrapper').css({'max-height':'calc(100vh - 300px)','overflow':'auto'}).find('.dt-buttons').addClass('float-end mb-2');
    });
    const buttons = $.fn.DataTable.Buttons ? [{extend:'csv', filename:'dge_'+ct}] : [];
    tbl.DataTable({paging:false,searching:true,info:false,ordering:true,order:[[2,'desc']],columnDefs:[{targets:[1,2,3],type:'num'}],fixedHeader:true,autoWidth:false,dom:'Bfrtip',buttons:buttons});
  }
  const baseLayout={
    ...PLOTLY_THEME.layout,
    paper_bgcolor:'#ffffff',
    plot_bgcolor:'#ffffff',
    margin:{l:60,r:20,t:50,b:60},
    xaxis:{showline:true,mirror:true,ticks:'outside',tickwidth:1,tickcolor:'#000',automargin:true},
    yaxis:{showline:true,mirror:true,ticks:'outside',tickwidth:1,tickcolor:'#000',automargin:true}
  };
  function updateBox(gene){
    const traces = (res.boxData[gene] || []).map(t => ({
      ...t,
      boxpoints: 'all',
      jitter: 0.4,
      pointpos: 0,
    }));
    Plotly.react('dgeBox', traces,
      {...baseLayout,xaxis:{...baseLayout.xaxis,title:res.groupLabel},yaxis:{...baseLayout.yaxis,title:'log1p counts'},title:gene},
      PLOTLY_THEME.config);
  }
  $('#dgeTable tbody').off('click','tr').on('click','tr',function(){updateBox($(this).data('gene'));});
  updateBox(res.defaultGene);
}

function parseHash(){
  const params=new URLSearchParams(window.location.hash.slice(1));
  return {tab:params.get('tab'), sub:params.get('sub')};
}
function setHash(tab, sub){
  const params=new URLSearchParams();
  if(tab) params.set('tab', tab);
  if(sub) params.set('sub', sub);
  window.location.hash = params.toString();
}
function showTab(tab, sub){
  if(currentTab && tab!==currentTab && document.querySelectorAll('.gl-container').length>CONTEXT_BUDGET){
    if(currentTab==='umapobs'){
      if(purgePlotsIn('#umapObsGrid_'+DOM)) umapObsPurged=true;
    } else if(currentTab==='qc'){
      if(currentSub==='Overview'){
        if(purgePlotsIn('#qc_umap')+purgePlotsIn('#qc_hist')){qcOverviewPurged=true; qcOverviewInit=false;}
      } else if(currentSub==='PerCluster'){
        if(purgePlotsIn('#qc_violin')){qcPerClusterPurged=true; qcPerClusterInit=false;}
      }
    }
  }
  $('.nav.nav-tabs .nav-link').removeClass('active');
  $(`.nav.nav-tabs .nav-link[data-tab='${tab}']`).addClass('active');
  $('.tabpane').removeClass('show');
  $('#'+tab).addClass('show');
  if(tab==='markers'&&!markersInit){populateMarkerSelectors(); markersInit=true;}
  if(tab==='topmarkers'&&!topMarkersInit){populateTopMarkerClusters(); topMarkersInit=true;}
  if(tab==='enrich'&&!enrichInit){populateEnrichClusters(); enrichInit=true;}
  if(tab==='tf'&&!tfInit){initTF(); tfInit=true;}
  if(tab==='composition'&&!compositionInit){initComposition(); compositionInit=true;}
  if(tab==='volcano' && !volcanoInit){ initVolcano(); volcanoInit=true; }
  if(tab==='dge' && !dgeInit){ initDGE(); dgeInit=true; }
  if(tab==='biology'&&!biologyInit){drawBiologyUMAP(); biologyInit=true;}
  if(tab==='qc') showQCSub(sub||'Overview');
  if(tab==='umap') plotClusters();
  if(tab==='umapobs'){drawUmapObs(); umapObsPurged=false;}
  if(tab==='markers' && lastMarkerGene) drawMarkerGene(lastMarkerGene);
  if(tab==='topmarkers' && lastTopMarkerGene) drawTopMarkerGene(lastTopMarkerGene);
  if(tab==='enrich') drawEnrich();
  if(tab==='tf') renderTF();
  if(tab==='coexpr') drawCoexpr();
  if(tab==='volcano') renderVolcano();   // re-draw when returning
  if(tab==='dge') renderDGE();
  if(tab==='qc'){
    const active=sub||'Overview';
    if(active==='Overview' && qcOverviewPurged){initQCOverview();}
    if(active==='PerCluster' && qcPerClusterPurged){renderQCPerCluster();}
  }
  currentTab=tab;
  currentSub=sub||'';
}
function showQCSub(sub){
  $('#qcSubTabs .nav-link').removeClass('active');
  $(`#qcSubTabs .nav-link[data-sub='${sub}']`).addClass('active');
  $('.qcsubpane').removeClass('show');
  $('#qc_'+sub).addClass('show');
  if(sub==='Overview'&&!qcOverviewInit){initQCOverview(); qcOverviewInit=true;}
  if(sub==='PerCluster'){if(!qcPerClusterInit){renderQCPerCluster(); qcPerClusterInit=true;}else{renderQCPerCluster();}}
  if(sub==='Batch'){renderBatchIntegration();}
}
window.addEventListener('hashchange',()=>{const {tab,sub}=parseHash(); if(tab) showTab(tab,sub);});
const HELP_CONTENT={
  umap:`<h5>Clusters &amp; Genes</h5>
<p><strong>Purpose:</strong> Visualise clusters and gene expression side-by-side.</p>
<p><strong>Panels:</strong> Left = clusters; Right = gene expression.</p>
<p><strong>Controls</strong></p>
<p>Gene: type and press Enter (autocomplete).</p>
<p>Plot clusters: refreshes the left panel after filtering/gating upstream.</p>
<p><strong>How to use</strong></p>
<p>Enter a gene in Gene.</p>
<p>Hover points to see cluster/annotation.</p>
<p>Click Plot clusters after applying gates or filters.</p>
<p><strong>Tips</strong></p>
<p>Test several genes to compare patterns.</p>
<p>Use exact gene symbols from your dataset.</p>`,
  umapobs:`<h5>Sample / Condition (UMAP by Obs)</h5>
<p><strong>Purpose:</strong> Break down expression by any categorical obs field (sample, condition, donor) as UMAP facets or violins.</p>
<p><strong>Controls</strong></p>
<p>Feature: gene (autocomplete).</p>
<p>Group by: pick any categorical obs (auto-selects common fields).</p>
<p>View: UMAP facets | Violin.</p>
<p>Show background: dim all cells in grey behind the highlighted group.</p>
<p>Plot: render with current settings.</p>
<p><strong>How to use</strong></p>
<p>Select Feature and Group by.</p>
<p>Choose View (facets for spatial context; violin for distributions).</p>
<p>Toggle Show background to retain global context; click Plot.</p>
<p><strong>Tips</strong></p>
<p>Violin plots are ideal for sample/condition comparisons.</p>
<p>The facet grid auto-arranges to fit the number of groups.</p>`,
  markers:`<h5>Marker genes</h5>
<p><strong>Purpose:</strong> Identify genes that define a cluster (standard DE).</p>
<p><strong>Controls:</strong> Method (Wilcoxon | t-test), Cluster.</p>
<p><strong>Output table:</strong> Score (test statistic) · logFC · adj.P (sortable; CSV export).</p>
<p><strong>How to use</strong></p>
<p>Pick Method and Cluster.</p>
<p>Click a gene to overlay it on the UMAP.</p>
<p><strong>Tips</strong></p>
<p>Compare Wilcoxon vs t-test for robustness.</p>`,
  topmarkers:`<h5>Neighbourhood-aware markers</h5>
<p><strong>Purpose:</strong> Find markers that distinguish a cluster from its nearest neighbours on the KNN graph (rather than vs all other cells).</p>
<p><strong>Controls:</strong> Cluster (and internal K/N settings, if exposed).</p>
<p><strong>How to use</strong></p>
<p>Select a Cluster to compute neighbour-aware DE.</p>
<p>Sort by Score, logFC, or adj.P; click a gene to plot on UMAP.</p>
<p><strong>Tips</strong></p>
<p>Use this to surface highly specific, local discriminators.</p>`,
  enrich:`<h5>Predicted annotation</h5>
<p><strong>Purpose:</strong> Suggest cell-type labels by matching clusters to reference markers.</p>
<p><strong>Panels:</strong> Left = per-cell enrichment (UMAP), Right = per-cluster scores (violin/table).</p>
<p><strong>How to use</strong></p>
<p>Select a Cluster to view top predicted labels.</p>
<p>Cross-check with Marker genes and TF Enrichment before finalising names.</p>
<p><strong>Tips</strong></p>
<p>Treat predictions as guidance; verify with multiple evidence sources.</p>`,
  tf:`<h5>TF Enrichment</h5>
<p><strong>Purpose:</strong> Explore transcription-factor activity programmes across clusters.</p>
<p><strong>Panels:</strong> Left = TF activity on UMAP, Right = distribution by cluster.</p>
<p><strong>How to use</strong></p>
<p>Pick a Cluster and TF (or rank TFs by cluster).</p>
<p>Inspect UMAP patterns and cluster-level distributions together.</p>
<p><strong>Tips</strong></p>
<p>Combine TF programmes with marker genes to strengthen annotations.</p>`,
  coexpr:`<h5>Co-expression</h5>
<p><strong>Purpose:</strong> Examine joint expression of two genes or their ratio.</p>
<p><strong>Modes</strong></p>
<p>Bivariate: quadrant colouring (A-high, B-high, both, low) via quantile cut-offs.</p>
<p>Ratio: A/B or log-ratio (continuous).</p>
<p><strong>Controls</strong></p>
<p>Gene A, Gene B · Quantile thresholds (Suggest provides auto cut-offs)</p>
<p>Contours (isolines), Clip %, Binarise, Global scale.</p>
<p><strong>How to use</strong></p>
<p>Set Gene A/B and choose Bivariate or Ratio.</p>
<p>Adjust thresholds; enable Contours as needed.</p>
<p>Use the right-side table to list extreme ratios/groups.</p>
<p><strong>Tips</strong></p>
<p>Ratios can reveal regulatory imbalances masked in single-gene views.</p>`,
  signatures:`<h5>Signatures</h5>
<p><strong>Purpose:</strong> Score custom gene lists (signatures) as virtual features.</p>
<p><strong>Controls</strong></p>
<p>Signature set: select or paste genes.</p>
<p>Scoring: mean/ssGSEA/ULM (as available).</p>
<p>Scale/normalise: options for comparability across cells/samples.</p>
<p><strong>How to use</strong></p>
<p>Select a signature (or add one).</p>
<p>Plot scores on UMAP and/or compare distributions by cluster/sample.</p>
<p>Export scores for downstream use.</p>
<p><strong>Tips</strong></p>
<p>Keep signatures concise and non-redundant to avoid noise.</p>`,
  composition:`<h5>Composition</h5>
<p><strong>Purpose:</strong> Compare group compositions per sample.</p>
<p><strong>Controls</strong></p>
<p>Sample key, Group by (cluster/annotation), Normalisation, Bar mode (stacked/grouped).</p>
<p>Export CSV: counts or proportions.</p>
<p><strong>How to use</strong></p>
<p>Choose Sample key and Group by.</p>
<p>Set Normalisation and Bar mode; render.</p>
<p>Export the table for reports.</p>
<p><strong>Tips</strong></p>
<p>Use alongside statistical summaries (if available) to add CIs/effect sizes.</p>`,
  qc_Overview:`<h5>QC</h5>
<p><strong>Purpose:</strong> Assess and filter cells by standard quality metrics.</p>
<p><strong>Controls</strong></p>
<p>Colour UMAP by nUMIs, nGenes, %MT, %Ribo, Doublet score.</p>
<p>Set Min/Max gates → Apply gates to update UMAP, histogram, and summary.</p>
<p>Reset restores defaults.</p>
<p><strong>How to use</strong></p>
<p>Inspect metric distributions (histogram + UMAP).</p>
<p>Set thresholds and Apply gates.</p>
<p>Review the Summary (pass/fail counts, medians).</p>
<p><strong>Tips</strong></p>
<p>Gate before downstream analyses to improve reliability.</p>`,
  qc_PerCluster:`<h5>QC → Per-cluster</h5>
<p>Pick a cluster (or Show all) to compare QC metrics as violins.</p>
<p>Dark violins = cells passing your current gates; faint violins = all cells.</p>
<p>The table below lists per-cluster n_cells, %pass, and median QC values (post-gating).</p>`,
  qc_Batch:`<h5>QC → Batch / Integration</h5>
<p>Colors indicate batch on the UMAP for quick composition checks.</p>
<p>iLISI/mixing UMAPs highlight batch mixing quality (higher is better).</p>
<p>Use alongside your pipeline’s integration diagnostics to spot batch-driven structure.</p>`,
  biology:`<h5>AI Insights</h5>
<p><strong>Purpose:</strong> Auto-generate editable narrative summaries (per cluster or per sample/condition) for figures, legends, and reports.</p>
<p><strong>What’s included</strong></p>
<p>Canonical label / fine label / confidence</p>
<p>Key markers (effect size &amp; specificity aware)</p>
<p>Supporting evidence: neighbour-aware markers, TFs/regulons, pathways/signatures, co-expression</p>
<p>Notes: composition shifts and QC outliers</p>`
};
if(HAS_PROT){
  HELP_CONTENT.umap=`<h5>Clusters &amp; Genes (CITE-seq)</h5>
<p><strong>Purpose:</strong> Compare RNA and protein expression on the same embedding.</p>
<p><strong>Panels:</strong> Left = clusters; Middle = RNA; Right = Protein (shown when enabled).</p>
<p><strong>Controls</strong></p>
<p>Modality: RNA | Protein | Both.</p>
<p>Link ranges: share colour scale across modalities.</p>
<p>Plot clusters: refreshes clusters after filtering/gating.</p>
<p><strong>How to use</strong></p>
<p>Choose Modality and search a Gene (RNA) or Protein.</p>
<p>Toggle Both to see RNA vs Protein simultaneously.</p>
<p>Use Link ranges to spot post-transcriptional shifts.</p>
<p><strong>Tips</strong></p>
<p>Protein often shows tighter dynamic range; link scales for fair comparisons.</p>`;
  HELP_CONTENT.umapobs=`<h5>Sample / Condition (UMAP by Obs)</h5>
<p><strong>Purpose:</strong> Break down expression by any categorical obs field (sample, condition, donor) as UMAP facets or violins.</p>
<p><strong>Controls</strong></p>
<p>Modality: RNA | Protein (CITE-seq).</p>
<p>Feature: gene/protein (autocomplete).</p>
<p>Group by: pick any categorical obs (auto-selects common fields).</p>
<p>View: UMAP facets | Violin.</p>
<p>Show background: dim all cells in grey behind the highlighted group.</p>
<p>Plot: render with current settings.</p>
<p><strong>How to use</strong></p>
<p>Select Feature and Group by.</p>
<p>Choose View (facets for spatial context; violin for distributions).</p>
<p>Toggle Show background to retain global context; click Plot.</p>
<p><strong>Tips</strong></p>
<p>Violin plots are ideal for sample/condition comparisons.</p>
<p>The facet grid auto-arranges to fit the number of groups.</p>`;
}
const TOUR_STEPS={
  qc_Overview:[
    "1. Use metric buttons to color the UMAP.",
    "2. Set gates and click Apply gates.",
    "3. Hover points and inspect the summary."
  ],
  qc_PerCluster:[
    "1. Pick a cluster or 'Show all'.",
    "2. Compare dark vs faint violins.",
    "3. Review the per-cluster table."
  ],
  qc_Batch:[
    "1. Color the UMAP by batch.",
    "2. Check iLISI/mixing UMAPs.",
    "3. Spot batch-driven structure."
  ],
  umap:[
    "1. Start typing a gene and press Enter.",
    "2. Use Plot clusters after gating.",
    "3. Hover points to see clusters."
  ],
  markers:[
    "1. Select a method and cluster.",
    "2. Sort or search the marker table.",
    "3. Click a gene to view expression."
  ],
  topmarkers:[
    "1. Choose a cluster.",
    "2. Inspect and sort neighborhood-aware markers.",
    "3. Click a gene to render its UMAP."
  ],
  enrich:[
    "1. Select a cluster and cell type.",
    "2. Examine enrichment on the UMAP.",
    "3. Review score distributions."
  ],
  tf:[
    "1. Pick a cluster and transcription factor.",
    "2. View TF activity on the UMAP.",
    "3. Read per-cluster distribution."
  ],
  coexpr:[
    "1. Enter Gene A and Gene B.",
    "2. Choose Bivariate or Ratio mode.",
    "3. Explore the ratio table and signature panel."
  ],
  composition:[
    "1. Inspect default composition.",
    "2. Change the grouping or normalization.",
    "3. Download CSV summaries."
  ],
  biology:[
    "1. Read cluster summaries.",
    "2. Check confidence and markers.",
    "3. Validate with other tabs."
  ]
};
function getHelpKey(){
  const tab=$('.nav.nav-tabs .nav-link.active').data('tab');
  let sub='';
  if(tab==='qc'){
    sub=$('#qcSubTabs .nav-link.active').data('sub')||'Overview';
  }
  const key=tab==='qc'?`qc_${sub}`:tab;
  return {tab,sub,key};
}
function startTour(key){
  const steps=TOUR_STEPS[key];
  if(!steps||!steps.length) return;
  let i=0;
  $('#tourText').text(steps[0]);
  $('#tourNext').text(steps.length>1?'Next':'Done');
  $('#tourOverlay').addClass('show');
  $('#tourNext').off('click').on('click',function(){
    i++;
    if(i<steps.length){
      $('#tourText').text(steps[i]);
      if(i===steps.length-1) $('#tourNext').text('Done');
    } else {
      $('#tourOverlay').removeClass('show');
    }
  });
}
function plotClusters(){
  drawUMAP();
  const g=$('#geneInput_'+DOM).val(); if(g) drawGeneTo('genePlot_'+DOM,g);
  const p=$('#proteinInput_'+DOM).val(); if(p) drawProteinTo('protPlot_'+DOM,p);
}
$(function(){
  if(!SAMPLE_KEY){
    $("a[data-tab='composition']").closest('li').remove();
    $('#composition').remove();
  }
  populateGenes();
  populateProteins();
  const rand=GENES[Math.floor(Math.random()*GENES.length)];
  $("#geneInput_"+DOM).val(rand);
  if(PROT_GENES.length===0){
      $('.protCtrl').hide();
      $('#clustCol_'+DOM+',#rnaCol_'+DOM).removeClass('col-lg-4').addClass('col-lg-6');
    } else {
      setUMAPView('BOTH');
      $('#viewBOTH_'+DOM).prop('checked',true);
      $('#viewToggle_'+DOM+' input').on('change',function(){setUMAPView(this.value);});
      const p0=PROT_GENES[0];
      $("#proteinInput_"+DOM).val(p0);
    }
    populateObsGroupBy();
    $('#obsGroupSel_'+DOM).on('change',drawUmapObs);
    $('#obsShowBackground_'+DOM).on('change',drawUmapObs);
    $('#umapObsPoints_'+DOM).on('change',drawUmapObs);
    $('#umapObsJitter_'+DOM).on('change',drawUmapObs);
    $('input[name="umapObsView_'+DOM+'"]').on('change',drawUmapObs);
    $('#umapObsFeat_'+DOM)
      .attr('list','geneList_'+DOM)
      .on('input',()=>{ umapObsGeneConfirmed=false; })
      .on('change',()=>{ umapObsGeneConfirmed=true; drawUmapObs(); });
    $('#umapObsPlot_'+DOM).on('click',()=>{ umapObsGeneConfirmed=true; drawUmapObs(); });
    if(HAS_PROT){
      $('#umapObsMod_'+DOM).on('change',function(){
        const m=$(this).val();
        $('#umapObsFeat_'+DOM).attr('list', m==='RNA' ? 'geneList_'+DOM : 'protList_'+DOM);
        setRandomUmapObsFeature(m);
        drawUmapObs();
      }).val('RNA');
    }
    setRandomUmapObsFeature('RNA');
    $('#linkRanges_'+DOM).on('change',function(){
      if(this.checked){
        const cp=document.getElementById('clusterPlot_'+DOM);
        if(cp&&cp.layout){
          const xr=cp.layout.xaxis.range, yr=cp.layout.yaxis.range;
          SYNC_IDS.forEach(o=>{if(o!==cp.id) Plotly.relayout(o,{'xaxis.range':xr,'yaxis.range':yr});});
      }
    }
  });
  const randA=GENES[Math.floor(Math.random()*GENES.length)];
  const randB=GENES[Math.floor(Math.random()*GENES.length)];
  $("#geneAInput_"+DOM).val(randA);
  $("#geneBInput_"+DOM).val(randB);
  $("#transformSel_"+DOM+" option[value='logratio']").prop('disabled',true);
  $("#geneAInput_"+DOM+",#geneBInput_"+DOM).on('input',function(){drawCoexpr();});
  $("#transformSel_"+DOM+",#quantileA_"+DOM+",#quantileB_"+DOM+",#clip_"+DOM+",#binarize_"+DOM+",#binarizeQ_"+DOM+",#globalScale_"+DOM).on('change input',drawCoexpr);
  $("#suggestA_"+DOM).on('click',()=>suggestCut('A'));
  $("#suggestB_"+DOM).on('click',()=>suggestCut('B'));
  $("#sigScoreBtn_"+DOM).on('click',scoreSignature);
  $("#modeSel_"+DOM).on('change',function(){
    const m=$(this).val();
    const tf=$("#transformSel_"+DOM);
    if(m==='ratio'){tf.find("option[value='logratio']").prop('disabled',false);}else{tf.val('raw');tf.find("option[value='logratio']").prop('disabled',true);} 
    drawCoexpr();
  });
  if(HAS_PROT){
    $("#methodLbl_"+DOM).text('Modality');
    const mSel=$("#methodSel_"+DOM);
    const tSel=$("#topModalitySel_"+DOM);
    const tLbl=$("#topModalityLbl_"+DOM);
    mSel.empty().append('<option value="RNA">RNA</option>').append('<option value="Protein">Protein</option>');
    tSel.empty().append('<option value="RNA">RNA</option>').append('<option value="Protein">Protein</option>');
    tLbl.removeClass('d-none');
    tSel.removeClass('d-none');
    mSel.val('RNA');
    tSel.val('RNA');
    const onModalityChange=function(){
      CURRENT_MODALITY=$(this).val();
      mSel.val(CURRENT_MODALITY);
      tSel.val(CURRENT_MODALITY);
      populateMarkerSelectors();
      populateTopMarkerClusters();
    };
    mSel.on('change',onModalityChange);
    tSel.on('change',onModalityChange);
  } else {
    $("#methodSel_"+DOM).on("change",updateMarkerClusters);
  }
  $("#clusterSel_"+DOM).on("change",function(){
    markerClusterByMod[CURRENT_MODALITY]=$(this).val();
    updateMarkerTable();
  });
  $("#topClusterSel_"+DOM).on("change",function(){
    topMarkerClusterByMod[CURRENT_MODALITY]=$(this).val();
    updateTopMarkerTable();
  });
  $("#markerTable_"+DOM).off("click", "tbody tr")
                        .on("click", "tbody tr", e => {
    const g = $(e.currentTarget).children().first().text();
    $("#geneInput_"+DOM).val(g);
    drawMarkerGene(g);
  });
  $("#enrichClusterSel_"+DOM).on("change",updateEnrichTypes);
  $("#enrichTypeSel_"+DOM).on("change",drawEnrich);
  $("#enrichDownload_"+DOM).on("click",downloadEnrichCSV);
  $(".nav.nav-tabs .nav-link").on("click",function(e){
    e.preventDefault();
    const tab=$(this).data("tab");
    const sub=tab==='qc'?$('#qcSubTabs .nav-link.active').data('sub'):'';
    setHash(tab, sub);
  });
  $("#qcSubTabs .nav-link").on("click",function(e){
    e.preventDefault();
    const sub=$(this).data('sub');
    setHash('qc', sub);
  });
  const init=parseHash();
  showTab(init.tab||'umap', init.sub);
  $("#plotCluster_"+DOM).on("click",plotClusters);
  let geneRAF=null;
  $("#geneInput_"+DOM).on("input",function(){
    const g=this.value;
    if(geneRAF) cancelAnimationFrame(geneRAF);
    geneRAF=requestAnimationFrame(()=>{
      const sym=baseGene(g);
      const fb=document.getElementById("geneFeedback_"+DOM);
      if(EXP[sym]){fb.textContent=""; drawGene(g);} else {fb.textContent="No match";}
    });
  });
  $("#proteinInput_"+DOM).on("input",function(){
    const p=this.value;
    if(PROT_INDEX[p] !== undefined){ drawProteinTo("protPlot_"+DOM,p); }
    });
    function to_markdown(text){
      return marked.parse(text);
    }
    const biology_md = inflateExp(§BIOLOGY_MD);
    const insightsBtn = $('#downloadInsightsBtn');

    function parseInsights(md){
      const blocks = md.split(/^###\s+/m).filter(Boolean);
      return blocks.map(b=>{
        const lines = b.split(/\n+/);
        const header = lines[0].trim();
        const cluster = header.replace(/^.*?\s+/, '');
        const get = prefix => {
          const line = lines.find(l=>l.startsWith(prefix+':'));
          return line ? line.split(':')[1].trim() : 'N/A';
        };
        const canonical = get('Canonical Label');
        const fine = get('Fine Label');
        const confidence = get('Confidence');
        const markers = get('Key Markers');
        const obsIdx = lines.findIndex(l=>l.startsWith('Key Markers'));
        const observations = obsIdx>=0 ? lines.slice(obsIdx+1).join(' ').replace(/\s+/g,' ').trim() : '';
        return {cluster, canonical, fine, confidence, markers, observations};
      });
    }

    function downloadInsights(md){
      const rows = parseInsights(md);
      if(!rows.length) return;
      const header = 'Cluster,Canonical label,Fine label,Cell confidence,Key markers,Observations';
      const csv = [header, ...rows.map(r=>[r.cluster, r.canonical, r.fine, r.confidence, r.markers, r.observations]
        .map(v=>'"'+v.replace(/"/g,'""')+'"').join(','))].join('\n');
      const blob = new Blob([csv], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'ai_insights.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    if (biology_md && biology_md.trim()) {
      $('#biologyContent').html(to_markdown(biology_md));
      insightsBtn.on('click', ()=>downloadInsights(biology_md));
    } else {
      insightsBtn.remove();
      $("a[data-tab='biology']").closest('li').remove();
      $('#biology').remove();
    }
  $('#helpChip').on('click',function(){
    const {key}=getHelpKey();
    $('#helpContent').html(HELP_CONTENT[key]||'<p>No help available.</p>');
    $('#helpOverlay').addClass('show');
    $('#helpBackdrop').addClass('show');
    $('#startTourBtn').off('click').on('click',function(){
      $('#helpOverlay').removeClass('show');
      $('#helpBackdrop').removeClass('show');
      startTour(key);
    });
  });
  $('.help-close,#helpBackdrop').on('click',function(){
    $('#helpOverlay').removeClass('show');
    $('#helpBackdrop').removeClass('show');
  });
  $('#tourOverlay').on('click',function(e){
    if(e.target.id==='tourOverlay') $('#tourOverlay').removeClass('show');
  });
});
</script>
<script>
  // CHANGELOG: Fill dynamic dataset facts in the About tab.
  (function(){
    const el = document.getElementById('about-cells');
    if (el && typeof NCELLS !== 'undefined') {
      el.textContent = NCELLS.toLocaleString();
    }
    // If you later expose other facts, set them here similarly.
  })();
</script>
</body>
</html>
